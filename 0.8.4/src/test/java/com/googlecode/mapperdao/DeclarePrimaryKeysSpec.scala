package com.googlecode.mapperdao
import org.specs2.mutable.SpecificationWithJUnit
import com.googlecode.mapperdao.jdbc.Setup

/**
 * @author kostantinos.kougios
 *
 * 13 Oct 2011
 */
class DeclarePrimaryKeysSpec extends SpecificationWithJUnit {
	import DeclarePrimaryKeysSpec._
	val (jdbc, driver, mapperDao) = Setup.setupMapperDao(TypeRegistry(ProductEntity, PriceEntity))

	"entity without PK's remove all items from collection" in {
		createTables
		val p = mapperDao.insert(ProductEntity, Product("x", Set(Price("GBP", 5, 7), Price("EUR", 5, 6), Price("EUR", 7, 8), Price("USD", 9, 10))))
		val newP = new Product(p.title, Set())
		val updated = mapperDao.update(ProductEntity, p, newP)
		updated must_== newP
		val loaded = mapperDao.select(ProductEntity, updated.id).get
		loaded must_== updated
	}

	"entity without PK's remove 2 items from collection" in {
		createTables
		val p = mapperDao.insert(ProductEntity, Product("x", Set(Price("GBP", 5, 7), Price("EUR", 5, 6), Price("EUR", 7, 8), Price("USD", 9, 10))))
		val newP = new Product(p.title, p.prices.filterNot(_.currency == "EUR"))
		val updated = mapperDao.update(ProductEntity, p, newP)
		updated must_== newP
		val loaded = mapperDao.select(ProductEntity, updated.id).get
		loaded must_== updated
	}

	"entity without PK's remove 1 item from collection" in {
		createTables
		val p = mapperDao.insert(ProductEntity, Product("x", Set(Price("GBP", 5, 7), Price("EUR", 5, 6), Price("EUR", 7, 8), Price("USD", 9, 10))))
		val newP = new Product(p.title, p.prices.filterNot(_.currency == "GBP"))
		val updated = mapperDao.update(ProductEntity, p, newP)
		updated must_== newP
		val loaded = mapperDao.select(ProductEntity, updated.id).get
		loaded must_== updated
	}

	"entity without PK's add 1 item from collection" in {
		createTables
		val p = mapperDao.insert(ProductEntity, Product("x", Set(Price("GBP", 5, 7), Price("EUR", 5, 6), Price("EUR", 7, 8), Price("USD", 9, 10))))
		val newP = new Product(p.title, p.prices + Price("GBP", 6, 8))
		val updated = mapperDao.update(ProductEntity, p, newP)
		updated must_== newP
		val loaded = mapperDao.select(ProductEntity, updated.id).get
		loaded must_== updated
	}

	"entity without PK's loaded correctly" in {
		createTables
		val product = mapperDao.insert(ProductEntity, Product("x", Set(Price("GBP", 5, 7), Price("EUR", 5, 6), Price("EUR", 7, 8), Price("USD", 9, 10))))
		val loaded = mapperDao.select(ProductEntity, product.id).get
		loaded must_== product
	}

	def createTables {
		Setup.dropAllTables(jdbc)
		Setup.queries(this, jdbc).update("one-to-many")
		Setup.database match {
			case "oracle" =>
				Setup.createSeq(jdbc, "ProductSeq")
			case _ =>
		}
	}

}

object DeclarePrimaryKeysSpec {
	case class Product(
		val title: String,
		val prices: Set[Price])

	case class Price(val currency: String, val unitPrice: Double, val salePrice: Double)

	object ProductEntity extends Entity[IntId, Product](classOf[Product]) {
		val id = intAutoGeneratedPK("id", Setup.database match {
			case "oracle" => "ProductSeq"
			case _ => null
		}, _.id)
		val title = string("title", _.title)
		val prices = oneToMany(PriceEntity, _.prices)

		def constructor(implicit m: ValuesMap) = new Product(title, prices) with IntId with Persisted {
			val id: Int = ProductEntity.id
		}
	}
	object PriceEntity extends SimpleEntity[Price](classOf[Price]) {
		val currency = string("currency", _.currency)
		val unitPrice = double("unitprice", _.unitPrice)
		val salePrice = double("saleprice", _.salePrice)
		// the unitprice doesn't make sense to be a PK, but we have it so that we can do extra tests
		val pks = declarePrimaryKeys("currency", "product_id", "unitprice")

		def constructor(implicit m: ValuesMap) = new Price(currency, unitPrice, salePrice) with Persisted
	}
}