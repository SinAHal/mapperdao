MapperDao supports lazy loading related data.

Lazy loading is implemented via class proxies, so there is reflection & bytecode generation involved but nothing worse than other popular ORM's.
There is also a way to lazy load related data via modifying the domain classes, but that's intrusive to the domain model. Both ways are explained
in this wiki page.

Lazy loading is only one way to avoid loading relationships. Please also see [skip loading](ConfigurableCRUD.md).

# Transparent Lazy Loading Via Proxies #

## Enabling Lazy Loading ##

Lets work with the following example of Person who owe houses:

```
case class Person(name: String, owns: Set[House])
case class House(address: String)

object HouseEntity extends Entity[Int,SurrogateIntId, House] {
	val id = key("id") autogenerated (_.id)
	val address = column("address") to (_.address)

	def constructor(implicit m) = new House(address) with Stored {
		val id: Int = HouseEntity.id
	}
}

object PersonEntity extends Entity[Int,SurrogateIntId, Person] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)
	val owns = onetomany(HouseEntity) getter ("owns") to (_.owns)

	def constructor(implicit m) = new Person(name, owns) with Stored {
		val id: Int = PersonEntity.id
	}
}
```

  * Add a `getter` declaration on your relationship:

`val owns = onetomany(HouseEntity) getter ("owns") to (_.owns)`

This getter declares the field that stores the `Set[House]`. Since MapperDao will use reflection to populate these, it needs to know
the field (named "owns") which stores the data.

  * Use a SelectConfig with a lazyLoad configuration:

```
val selectConfig = SelectConfig(lazyLoad = LazyLoad.all)
val person=mapperDao.select(selectConfig, PersonEntity, 5)
```

Now `person` contains the person with id=5 but the houses that the person owns are not yet loaded from the database.
Upon first access of person.owns, MapperDao will fetch the houses from the database.

Lazy loading can be further configured to lazy load only a certain set of relationships. LazyLoad.lazyLoaded can contain a set of those, i.e.

```
LazyLoad(lazyLoaded=Set(PersonEntity.owns))
```

### Updating lazy loaded entities ###

In order for MapperDao to update lazy loaded entities, it will have to fully load the entity (this is mostly due to that we need to support immutable updates where as other ORMS are based on mutable state and can skip the fetch if the setter wasn't called). This can be overriden via configuration of the update:

```
val person = Person("Kostas", Set(House("Rhodes"), House("Athens")))
val inserted = mapperDao.insert(PersonEntity, person)
val selected = mapperDao.select(selectConfig, PersonEntity, inserted.id).get

val updated = mapperDao.update(UpdateConfig(skip = Set(PersonEntity.owns)), PersonEntity, Person("updated kostas", Set()))
```

The above code will update the Person.name but will not update Person.owns since we configured it to `skip = Set(PersonEntity.owns)` .
Effectively, after this update if we reload the person, we will get Person("updated kostas", Set(House("Rhodes"), House("Athens"))).


Some examples:

[ManyToManyLazyLoadSuite](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/ManyToManyLazyLoadSuite.scala)
[ManyToOneLazyLoadSuite](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/ManyToOneLazyLoadSuite.scala)
[OneToManyLazyLoadSuite](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/OneToManyLazyLoadSuite.scala)
[OneToOneLazyLoadSuite](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/OneToOneLazyLoadSuite.scala)

## Querying with Lazy Loading ##

In a similar manner when querying, a `LazyLoad` within a `QueryConfig` can be used to lazy load entities.

# Lazy Loading Via Scala's by-name parameters #

There is a pure Scala way to achieve lazy loading but it requires modification of the domain classes. It also then is not
configurable, relationships will be lazy loaded depending on how the domain class is coded. All by-name parameters will be
lazy loaded.

Lets again take an example of a many-to-many relationship:

```
class Product(val id: Int, val name: String, attributes: Set[Attribute])
class Attribute(val id: Int, val name: String, val value: String)

object ProductEntity extends Entity[Int,NaturalIntId,Product] {
	val id = key("id") to (_.id)
	val name = column("name") to (_.name)
	val attributes = manytomany(AttributeEntity) to (_.attributes)
	def constructor(implicit m) = new Product(id, name, attributes) with Stored
}

object AttributeEntity extends Entity[Int,NaturalIntId,Attribute] {
	val id = key("id") to (_.id)
	val name = column("name") to (_.name)
	val value = column("value") to (_.value)

	def constructor(implicit m) = new Attribute(id, name, value) with Stored
}
```

Please notice the constructor of ProductEntity:

```
def constructor(implicit m) = new Product(id, name, attributes) with Stored
```

`attributes` is implicitly converted to a `Set[Attribute]` by MapperDao. The query to the database occurs when this implicit conversion happens.
If we can delay that conversion, then the query to the database will be delayed too. Here is the modified Product class that delays the
implicit conversion:

```
class Product(val id: Int, val name: String, attrs: => Set[Attribute]) {
	def attributes = attrs
}
```

Now the attrs is a by-name parameter and the implicit conversion will happen when we call product.attributes. At that time, mapperdao will
query the database, effectively we achieved lazy loading of the attributes.

With this approach we don't need to specify LazyLoad when selecting or querying. Lazy load of `attributes` is by default on.

There are some drawbacks of this approach:

  * not configurable, all by-name params will be lazy loaded (but you can invoke them inside your dao's to force load them)
  * it makes working with case classes hard as a by-name can't be a constructor parameter of a case class
  * intrusive for the domain model
  * hard to create mutable entities

Example:

[ManyToManyManuallyLazyLoadSuite](https://code.google.com/p/mapperdao/source/browse/src/test/java/com/googlecode/mapperdao/ManyToManyManuallyLazyLoadSuite.scala)
