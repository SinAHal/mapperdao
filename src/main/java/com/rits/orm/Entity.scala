package com.rits.orm
import java.util.Calendar

/**
 * @author kostantinos.kougios
 *
 * 13 Aug 2011
 */
abstract class Entity[PC, T](private val table: String, val clz: Class[T]) {

	def this(clz: Class[T]) = this(clz.getSimpleName, clz)

	val constructor: ValuesMap => T with PC with Persisted

	private var persistedColumns = List[ColumnInfoBase[T with PC, _]]()
	private var columns = List[ColumnInfoBase[T, _]]();

	protected[orm] var tpe: Type[PC, T] = _

	protected[orm] def init {
		if (tpe != null) throw new IllegalStateException("Already initialized!")
		tpe = Type[PC, T](clz, constructor, Table(table, columns.reverse, persistedColumns))
	}

	override def hashCode = table.hashCode
	override def equals(o: Any) = o match {
		case e: Entity[PC, T] => true
		case _ => false
	}

	override def toString = "%s(%s,%s)".format(getClass.getSimpleName, table, clz.getName)
	/**
	 * one to many mapping from T to a traversable of an other entity E. The mapping alias is generated by the class name +"Alias".
	 * If more than 1 oneToMany for the same E exist in a class, the alias should be provided manually using the
	 * oneToMany[E](alias: String, foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E])
	 * method
	 *
	 * @foreignClz		the refered entity
	 * @columnToValue	the function from T => Traversable[Any] that accesses the field of T to return the Traversable of E
	 */
	def oneToMany[E](foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E]): ColumnInfoTraversableOneToMany[T, E] = oneToMany(foreignClz.getSimpleName + "_Alias", foreignClz, foreignKeyColumn, columnToValue)
	/**
	 * one to many mapping from T to a traversable of an other entity E
	 *
	 * @alias			the alias that can be used to construct T.
	 * @foreignClz		the refered entity
	 * @columnToValue	the function from T => Traversable[Any] that accesses the field of T to return the Traversable of E
	 */
	def oneToMany[E](alias: String, foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E]): ColumnInfoTraversableOneToMany[T, E] =
		{
			val ci = ColumnInfoTraversableOneToMany[T, E](OneToMany(TypeRef(alias, foreignClz), Column.many(foreignKeyColumn)), columnToValue)
			columns ::= ci
			ci
		}

	def manyToOne[F](column: String, foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] = manyToOne(column + "_Alias", column, foreignClz, columnToValue)

	/**
	 * many to one mapping from T to F.
	 */
	def manyToOne[F](alias: String, column: String, foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		{
			require(alias != column)
			manyToOne(alias, List(column), foreignClz, columnToValue)
		}

	def manyToOne[F](alias: String, columns: List[String], foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		{
			val ci = ColumnInfoManyToOne(ManyToOne(columns.map(c => Column(c)), TypeRef(alias, foreignClz)), columnToValue)
			this.columns ::= ci
			ci
		}

	def manyToMany[F](linkTable: String, leftColumn: String, rightColumn: String, referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] = manyToMany(linkTable, linkTable, leftColumn, rightColumn, referencedType, columnToValue)

	def manyToMany[F](alias: String, linkTable: String, leftColumn: String, rightColumn: String, referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] =
		{
			val ci = ColumnInfoTraversableManyToMany[T, F](
				ManyToMany(
					LinkTable(linkTable, List(Column(leftColumn)), List(Column(rightColumn))),
					TypeRef(alias, referencedType)
				),
				columnToValue
			)
			columns ::= ci
			ci
		}

	private def basic[V](column: String, columnToValue: T => V): ColumnInfo[T, V] =
		{
			val ci = ColumnInfo[T, V](Column(column), columnToValue)
			columns ::= ci
			ci
		}
	/**
	 * basic mapping to a database column
	 */
	def int(column: String, columnToValue: T => Int): ColumnInfo[T, Int] = basic(column, columnToValue)
	def byte(column: String, columnToValue: T => Byte): ColumnInfo[T, Byte] = basic(column, columnToValue)
	def long(column: String, columnToValue: T => Long): ColumnInfo[T, Long] = basic(column, columnToValue)
	def short(column: String, columnToValue: T => Short): ColumnInfo[T, Short] = basic(column, columnToValue)
	def float(column: String, columnToValue: T => Float): ColumnInfo[T, Float] = basic(column, columnToValue)
	def double(column: String, columnToValue: T => Double): ColumnInfo[T, Double] = basic(column, columnToValue)
	def boolean(column: String, columnToValue: T => Boolean): ColumnInfo[T, Boolean] = basic(column, columnToValue)
	def char(column: String, columnToValue: T => Char): ColumnInfo[T, Char] = basic(column, columnToValue)
	def string(column: String, columnToValue: T => String): ColumnInfo[T, String] = basic(column, columnToValue)
	def datetime(column: String, columnToValue: T => org.joda.time.DateTime): ColumnInfo[T, org.joda.time.DateTime] = basic(column, columnToValue)
	def calendar(column: String, columnToValue: T => Calendar): ColumnInfo[T, Calendar] = basic(column, columnToValue)

	/**
	 * an autogenerated column that is a primary key
	 */
	def autoGeneratedPK[V](idColumn: String, columnToValue: T with PC => V): ColumnInfo[T with PC, V] =
		{
			var ci = ColumnInfo(PK(AutoGenerated(idColumn)), columnToValue)
			persistedColumns ::= ci
			ci
		}

	/**
	 * map a primary key column. Use autoGeneratedPK to map a primary key that is auto generated
	 */
	def pk[V](idColumn: String, columnToValue: T => V): ColumnInfo[T, V] =
		{
			var ci = ColumnInfo(PK(Column(idColumn)), columnToValue)
			columns ::= ci
			ci
		}
}

abstract class SimpleEntity[T](table: String, clz: Class[T]) extends Entity[AnyRef, T](table, clz) {
	def this(clz: Class[T]) = this(clz.getSimpleName, clz)
}
