package com.googlecode.mapperdao

/**
 * mapping tables to entities
 *
 * @author kostantinos.kougios
 *
 * 12 Jul 2011
 */

case class Table[PC, T](name: String, columnInfosPlain: List[ColumnInfoBase[T, _]], extraColumnInfosPersisted: List[ColumnInfoBase[T with PC, _]], val unusedPKs: List[SimpleColumn]) {

	val columns: List[ColumnBase] = columnInfosPlain.map(_.column) ::: extraColumnInfosPersisted.map(_.column)
	// the primary keys for this table
	val primaryKeys: List[PK] = columns.collect {
		case pk: PK => pk
	}
	val primaryKeyColumns: List[SimpleColumn] = primaryKeys.map(_.column)
	val primaryKeysAsCommaSeparatedList = primaryKeyColumns.map(_.columnName).mkString(",")

	val autoGeneratedColumns: List[ColumnBase] = columns.filter(_.isAutoGenerated)
	val columnsWithoutAutoGenerated: List[ColumnBase] = columns.filterNot(_.isAutoGenerated)

	val simpleTypeColumns: List[ColumnBase] = columns.collect {
		case c: Column => c
		case pk: PK => pk
	}

	val simpleTypeSequenceColumns: List[ColumnBase] = simpleTypeColumns.filter(_.isSequence)
	val simpleTypeAutoGeneratedColumns: List[ColumnBase] = simpleTypeColumns.filter(_.isAutoGenerated)
	val simpleTypeNotAutoGeneratedColumns: List[ColumnBase] = simpleTypeColumns.filterNot(_.isAutoGenerated)

	val simpleTypeColumnInfos = columnInfosPlain.collect {
		case ci: ColumnInfo[T, _] => ci
	}

	val oneToOneColumns: List[OneToOne[Any, Any]] = columns.collect {
		case c: OneToOne[Any, Any] => c
	}

	val oneToOneReverseColumns: List[OneToOneReverse[Any, Any]] = columns.collect {
		case c: OneToOneReverse[Any, Any] => c
	}

	val oneToManyColumns: List[OneToMany[Any, Any]] = columns.collect {
		case c: OneToMany[Any, Any] => c
	}
	val manyToOneColumns: List[ManyToOne[_, _]] = columns.collect {
		case mto: ManyToOne[_, _] => mto
	}
	val manyToOneColumnsFlattened: List[Column] = columns.collect {
		case ManyToOne(columns: List[Column], _) => columns
	}.flatten

	val manyToManyColumns: List[ManyToMany[Any, Any]] = columns.collect {
		case c: ManyToMany[Any, Any] => c
	}

	val oneToOneColumnInfos: List[ColumnInfoOneToOne[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOne[T, _, _] => c
	}
	val oneToOneReverseColumnInfos: List[ColumnInfoOneToOneReverse[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOneReverse[T, _, _] => c
	}

	val oneToManyColumnInfos: List[ColumnInfoTraversableOneToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[T, _, _] => c
	}
	val manyToOneColumnInfos: List[ColumnInfoManyToOne[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoManyToOne[T, _, _] => c
	}
	val manyToManyColumnInfos: List[ColumnInfoTraversableManyToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, _, _] => c
	}

	val columnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T, _]] = columnInfosPlain.map(ci => (ci.column, ci)).toMap
	val pcColumnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T with PC, _]] = extraColumnInfosPersisted.map(ci => (ci.column, ci)).toMap

	val manyToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableManyToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, _, _] => (c.column, c)
	}.toMap

	val oneToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableOneToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[T, _, _] => (c.column, c)
	}.toMap

	def toListOfPrimaryKeyValues(o: T): List[Any] = toListOfPrimaryKeyAndValueTuples(o).map(_._2)
	def toListOfPrimaryKeyAndValueTuples(o: T): List[(PK, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)
	def toListOfPrimaryKeySimpleColumnAndValueTuples(o: T): List[(SimpleColumn, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)
	def toListOfUnusedPrimaryKeySimpleColumnAndValueTuples(o: T): List[(SimpleColumn, Any)] = toListOfColumnAndValueTuples(unusedPKs, o)

	def toListOfColumnAndValueTuples[CB <: ColumnBase](columns: List[CB], o: T): List[(CB, Any)] = columns.map { c =>
		val ctco = columnToColumnInfoMap.get(c)
		if (ctco.isDefined) {
			if (o == null) (c, null) else (c, ctco.get.columnToValue(o))
		} else {
			o match {
				case pc: T with PC => (c, pcColumnToColumnInfoMap(c).columnToValue(pc))
				case null => (c, null)
			}
		}
	}

	def toColumnAndValueMap(columns: List[ColumnBase], o: T): Map[ColumnBase, Any] = columns.map { c => (c, columnToColumnInfoMap(c).columnToValue(o)) }.toMap
	def toPCColumnAndValueMap(columns: List[ColumnBase], o: T with PC): Map[ColumnBase, Any] = columns.map { c => (c, pcColumnToColumnInfoMap(c).columnToValue(o)) }.toMap

	def toColumnAliasAndValueMap(columns: List[ColumnBase], o: T): Map[String, Any] = toColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))
	def toPCColumnAliasAndValueMap(columns: List[ColumnBase], o: T with PC): Map[String, Any] = toPCColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))
}

case class LinkTable(name: String, left: List[Column], right: List[Column])

/**
 * Columns
 */

protected abstract class ColumnBase {
	def columnName: String
	def alias: String

	def isAutoGenerated: Boolean
	def isSequence: Boolean
}

abstract class SimpleColumn extends ColumnBase

case class Column(name: String) extends SimpleColumn {
	def columnName = name
	def alias = name
	def isAutoGenerated = false
	def isSequence = false
}

case class AutoGenerated(name: String, sequence: Option[String]) extends SimpleColumn {
	def columnName = name
	def alias = name
	def isAutoGenerated = true
	def isSequence = sequence.isDefined
}

case class PK(column: SimpleColumn) extends SimpleColumn {
	def columnName = column.columnName
	def alias = columnName
	def isAutoGenerated = column.isAutoGenerated
	def isSequence = column.isSequence
}

protected abstract class ColumnRelationshipBase[FPC, F](foreign: TypeRef[FPC, F]) extends ColumnBase

case class OneToOne[FPC, F](foreign: TypeRef[FPC, F], selfColumns: List[Column]) extends ColumnRelationshipBase(foreign) {
	def columnName = throw new IllegalStateException("OneToOne doesn't have a columnName")
	def alias = foreign.alias
	def isAutoGenerated = false
	def isSequence = false
}

case class OneToOneReverse[FPC, F](foreign: TypeRef[FPC, F], foreignColumns: List[Column]) extends ColumnRelationshipBase(foreign) {
	def columnName = throw new IllegalStateException("OneToOneReverse doesn't have a columnName")
	def alias = foreign.alias
	def isAutoGenerated = false
	def isSequence = false
}

case class OneToMany[FPC, F](foreign: TypeRef[FPC, F], foreignColumns: List[Column]) extends ColumnRelationshipBase(foreign) {
	def columnName = throw new IllegalStateException("OneToMany doesn't have a columnName")
	def alias = foreign.alias
	def isAutoGenerated = false
	def isSequence = false
}

case class ManyToOne[FPC, F](columns: List[Column], foreign: TypeRef[FPC, F]) extends ColumnRelationshipBase(foreign) {
	def columnName = throw new IllegalStateException("ManyToOne doesn't have a columnName")
	def alias = foreign.alias
	def isAutoGenerated = false
	def isSequence = false
}

case class ManyToMany[FPC, F](linkTable: LinkTable, foreign: TypeRef[FPC, F]) extends ColumnRelationshipBase(foreign) {
	def columnName = throw new IllegalStateException("ManyToMany doesn't have a columnName")
	def alias = foreign.alias
	def isAutoGenerated = false
	def isSequence = false
}

case class Type[PC, T](val clz: Class[T], val constructor: ValuesMap => T with PC with Persisted, table: Table[PC, T])

case class TypeRef[FPC, F](alias: String, entity: Entity[FPC, F])

/**
 * Column Infos
 */
class ColumnInfoBase[T, V](val column: ColumnBase, val columnToValue: T => V)

case class ColumnInfo[T, V](override val column: SimpleColumn, override val columnToValue: T => V, val dataType: Class[V]) extends ColumnInfoBase[T, V](column, columnToValue)

/**
 * relationship column infos
 */
class ColumnInfoRelationshipBase[T, V, FPC, F](override val column: ColumnRelationshipBase[FPC, F], override val columnToValue: T => V) extends ColumnInfoBase[T, V](column, columnToValue)

case class ColumnInfoOneToOne[T, FPC, F](override val column: OneToOne[FPC, F], override val columnToValue: (_ >: T) => F) extends ColumnInfoRelationshipBase[T, F, FPC, F](column, columnToValue)
case class ColumnInfoOneToOneReverse[T, FPC, F](override val column: OneToOneReverse[FPC, F], override val columnToValue: (_ >: T) => F) extends ColumnInfoRelationshipBase[T, F, FPC, F](column, columnToValue)
case class ColumnInfoTraversableOneToMany[T, FPC, F](override val column: OneToMany[FPC, F], override val columnToValue: (_ >: T) => Traversable[F]) extends ColumnInfoRelationshipBase[T, Traversable[F], FPC, F](column, columnToValue)
case class ColumnInfoManyToOne[T, FPC, F](override val column: ManyToOne[FPC, F], override val columnToValue: (_ >: T) => F) extends ColumnInfoRelationshipBase[T, F, FPC, F](column, columnToValue)
case class ColumnInfoTraversableManyToMany[T, FPC, F](override val column: ManyToMany[FPC, F], override val columnToValue: T => Traversable[F]) extends ColumnInfoRelationshipBase[T, Traversable[F], FPC, F](column, columnToValue)
