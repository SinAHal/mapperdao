package com.googlecode.mapperdao
import java.util.Calendar
import org.joda.time.DateTime

/**
 * @author kostantinos.kougios
 *
 * 13 Aug 2011
 */
abstract class Entity[PC, T](protected[mapperdao] val table: String, val clz: Class[T]) {

	def this(clz: Class[T]) = this(clz.getSimpleName, clz)

	def constructor(implicit m: ValuesMap): T with PC with Persisted

	protected[mapperdao] var persistedColumns = List[ColumnInfoBase[T with PC, _]]()
	protected[mapperdao] var columns = List[ColumnInfoBase[T, _]]();
	protected[mapperdao] var unusedPKs = List[SimpleColumn]()

	override def hashCode = table.hashCode
	override def equals(o: Any) = o match {
		case e: Entity[PC, T] => table == e.table && clz == e.clz
		case _ => false
	}

	override def toString = "%s(%s,%s)".format(getClass.getSimpleName, table, clz.getName)

	protected def oneToOne[F](alias: String, foreignClz: Class[F], columns: List[String], columnToValue: T => F): ColumnInfoOneToOne[T, F] =
		{
			val ci = ColumnInfoOneToOne(OneToOne(TypeRef(alias, foreignClz), columns.map(Column(_))), columnToValue)
			this.columns ::= ci
			ci
		}
	protected def oneToOne[F](foreignClz: Class[F], column: String, columnToValue: T => F): ColumnInfoOneToOne[T, F] =
		oneToOne(foreignClz.getSimpleName + "_Alias", foreignClz, List(column), columnToValue)
	protected def oneToOne[F](foreignClz: Class[F], columnToValue: T => F): ColumnInfoOneToOne[T, F] =
		oneToOne(foreignClz, foreignClz.getSimpleName.toLowerCase + "_id", columnToValue)

	protected def oneToOneReverse[F](alias: String, foreignClz: Class[F], foreignColumns: List[String], columnToValue: T => F): ColumnInfoOneToOneReverse[T, F] =
		{
			val ci = ColumnInfoOneToOneReverse(OneToOneReverse(TypeRef(alias, foreignClz), foreignColumns.map(Column(_))), columnToValue)
			this.columns ::= ci
			ci
		}
	protected def oneToOneReverse[F](foreignClz: Class[F], foreignColumn: String, columnToValue: T => F): ColumnInfoOneToOneReverse[T, F] =
		oneToOneReverse(foreignClz.getSimpleName + "_Alias", foreignClz, List(foreignColumn), columnToValue)
	protected def oneToOneReverse[F](foreignClz: Class[F], columnToValue: T => F): ColumnInfoOneToOneReverse[T, F] =
		oneToOneReverse(foreignClz, clz.getSimpleName.toLowerCase + "_id", columnToValue)
	/**
	 * one to many mapping from T to a traversable of an other entity E. The mapping alias is generated by the class name +"Alias".
	 * If more than 1 oneToMany for the same E exist in a class, the alias should be provided manually using the
	 * oneToMany[E](alias: String, foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E])
	 * method
	 *
	 * @foreignClz		the refered entity
	 * @columnToValue	the function from T => Traversable[Any] that accesses the field of T to return the Traversable of E
	 */
	protected def oneToMany[E](foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E]): ColumnInfoTraversableOneToMany[T, E] =
		oneToMany(foreignClz.getSimpleName + "_Alias", foreignClz, foreignKeyColumn, columnToValue)
	protected def oneToMany[E](foreignClz: Class[E], columnToValue: T => Traversable[E]): ColumnInfoTraversableOneToMany[T, E] =
		oneToMany(foreignClz, clz.getSimpleName.toLowerCase + "_id", columnToValue)

	/**
	 * one to many mapping from T to a traversable of an other entity E
	 *
	 * @alias			the alias that can be used to construct T.
	 * @foreignClz		the refered entity
	 * @columnToValue	the function from T => Traversable[Any] that accesses the field of T to return the Traversable of E
	 */
	protected def oneToMany[E](alias: String, foreignClz: Class[E], foreignKeyColumn: String, columnToValue: T => Traversable[E]): ColumnInfoTraversableOneToMany[T, E] =
		{
			val ci = ColumnInfoTraversableOneToMany[T, E](OneToMany(TypeRef(alias, foreignClz), Column.many(foreignKeyColumn)), columnToValue)
			this.columns ::= ci
			ci
		}

	protected def manyToOne[F](column: String, foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		manyToOne(column + "_Alias", column, foreignClz, columnToValue)
	protected def manyToOne[F](foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		manyToOne(foreignClz.getSimpleName.toLowerCase + "_id", foreignClz, columnToValue)

	/**
	 * many to one mapping from T to F.
	 */
	protected def manyToOne[F](alias: String, column: String, foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		{
			require(alias != column)
			manyToOne(alias, List(column), foreignClz, columnToValue)
		}

	protected def manyToOne[F](alias: String, columns: List[String], foreignClz: Class[F], columnToValue: T => F): ColumnInfoManyToOne[T, F] =
		{
			val ci = ColumnInfoManyToOne(ManyToOne(columns.map(c => Column(c)), TypeRef(alias, foreignClz)), columnToValue)
			this.columns ::= ci
			ci
		}

	protected def manyToMany[F](linkTable: String, leftColumn: String, rightColumn: String, referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] =
		manyToMany(linkTable, linkTable, leftColumn, rightColumn, referencedType, columnToValue)
	protected def manyToMany[F](referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] =
		manyToMany(clz.getSimpleName + "_" + referencedType.getSimpleName, clz.getSimpleName.toLowerCase + "_id", referencedType.getSimpleName.toLowerCase + "_id", referencedType, columnToValue)
	protected def manyToManyReverse[F](referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] =
		manyToMany(referencedType.getSimpleName + "_" + clz.getSimpleName, clz.getSimpleName.toLowerCase + "_id", referencedType.getSimpleName.toLowerCase + "_id", referencedType, columnToValue)

	protected def manyToMany[F](alias: String, linkTable: String, leftColumn: String, rightColumn: String, referencedType: Class[F], columnToValue: T => Traversable[F]): ColumnInfoTraversableManyToMany[T, F] =
		{
			val ci = ColumnInfoTraversableManyToMany[T, F](
				ManyToMany(
					LinkTable(linkTable, List(Column(leftColumn)), List(Column(rightColumn))),
					TypeRef(alias, referencedType)
				),
				columnToValue
			)
			this.columns ::= ci
			ci
		}

	private def basic[V](column: String, columnToValue: T => V, dataType: Class[V]): ColumnInfo[T, V] =
		{
			val ci = ColumnInfo[T, V](Column(column), columnToValue, dataType)
			this.columns ::= ci
			ci
		}
	/**
	 * basic mapping to a database column
	 */
	protected def int(column: String, columnToValue: T => Int): ColumnInfo[T, Int] = basic(column, columnToValue, classOf[Int])
	protected def byte(column: String, columnToValue: T => Byte): ColumnInfo[T, Byte] = basic(column, columnToValue, classOf[Byte])
	protected def long(column: String, columnToValue: T => Long): ColumnInfo[T, Long] = basic(column, columnToValue, classOf[Long])
	protected def short(column: String, columnToValue: T => Short): ColumnInfo[T, Short] = basic(column, columnToValue, classOf[Short])
	protected def float(column: String, columnToValue: T => Float): ColumnInfo[T, Float] = basic(column, columnToValue, classOf[Float])
	protected def double(column: String, columnToValue: T => Double): ColumnInfo[T, Double] = basic(column, columnToValue, classOf[Double])
	protected def boolean(column: String, columnToValue: T => Boolean): ColumnInfo[T, Boolean] = basic(column, columnToValue, classOf[Boolean])
	protected def char(column: String, columnToValue: T => Char): ColumnInfo[T, Char] = basic(column, columnToValue, classOf[Char])
	protected def string(column: String, columnToValue: T => String): ColumnInfo[T, String] = basic(column, columnToValue, classOf[String])
	protected def datetime(column: String, columnToValue: T => org.joda.time.DateTime): ColumnInfo[T, org.joda.time.DateTime] = basic(column, columnToValue, classOf[org.joda.time.DateTime])
	protected def calendar(column: String, columnToValue: T => Calendar): ColumnInfo[T, Calendar] = basic(column, columnToValue, classOf[Calendar])
	protected def bigInt(column: String, columnToValue: T => BigInt): ColumnInfo[T, BigInt] = basic(column, columnToValue, classOf[BigInt])
	protected def bigDecimal(column: String, columnToValue: T => BigDecimal): ColumnInfo[T, BigDecimal] = basic(column, columnToValue, classOf[BigDecimal])

	/**
	 * an autogenerated column that is a primary key
	 */
	protected def autoGeneratedPK[V](idColumn: String, columnToValue: T with PC => V, dataType: Class[V], sequence: Option[String]): ColumnInfo[T with PC, V] =
		{
			var ci = ColumnInfo(PK(AutoGenerated(idColumn, sequence)), columnToValue, dataType)
			this.persistedColumns ::= ci
			ci
		}
	protected def intAutoGeneratedPK(idColumn: String, columnToValue: T with PC => Int): ColumnInfo[T with PC, Int] = autoGeneratedPK(idColumn, columnToValue, classOf[Int], None)
	protected def intAutoGeneratedPK(idColumn: String, sequence: String, columnToValue: T with PC => Int): ColumnInfo[T with PC, Int] = autoGeneratedPK(idColumn, columnToValue, classOf[Int], Some(sequence))
	protected def longAutoGeneratedPK(idColumn: String, columnToValue: T with PC => Long): ColumnInfo[T with PC, Long] = autoGeneratedPK(idColumn, columnToValue, classOf[Long], None)
	protected def longAutoGeneratedPK(idColumn: String, sequence: String, columnToValue: T with PC => Long): ColumnInfo[T with PC, Long] = autoGeneratedPK(idColumn, columnToValue, classOf[Long], Some(sequence))

	/**
	 * map a primary key column. Use autoGeneratedPK to map a primary key that is auto generated
	 */
	protected def pk[V](idColumn: String, columnToValue: T => V, dataType: Class[V]): ColumnInfo[T, V] =
		{
			var ci = ColumnInfo(PK(Column(idColumn)), columnToValue, dataType)
			this.columns ::= ci
			ci
		}
	protected def intPK(idColumn: String, columnToValue: T => Int): ColumnInfo[T, Int] = pk(idColumn, columnToValue, classOf[Int])
	protected def longPK(idColumn: String, columnToValue: T => Long): ColumnInfo[T, Long] = pk(idColumn, columnToValue, classOf[Long])
	protected def stringPK(idColumn: String, columnToValue: T => String): ColumnInfo[T, String] = pk(idColumn, columnToValue, classOf[String])

	/**
	 * declare any primary keys that are not used for any mappings
	 */
	protected def declarePrimaryKeys(pks: String*): Unit = pks.foreach { pk =>
		unusedPKs ::= Column(pk)
	}
	// implicit conversions
	protected implicit def columnToBoolean(ci: ColumnInfo[T, Boolean])(implicit m: ValuesMap): Boolean = m(ci)
	protected implicit def columnToByte(ci: ColumnInfo[T, Byte])(implicit m: ValuesMap): Byte = m(ci)
	protected implicit def columnToShort(ci: ColumnInfo[T, Short])(implicit m: ValuesMap): Short = m(ci)
	protected implicit def columnToInt(ci: ColumnInfo[T, Int])(implicit m: ValuesMap): Int = m(ci)
	protected implicit def columnToIntIntId(ci: ColumnInfo[T with IntId, Int])(implicit m: ValuesMap): Int = m(ci)
	protected implicit def columnToLong(ci: ColumnInfo[T, Long])(implicit m: ValuesMap): Long = m(ci)
	protected implicit def columnToLongLongId(ci: ColumnInfo[T with LongId, Long])(implicit m: ValuesMap): Long = m(ci)
	protected implicit def columnToDateTime(ci: ColumnInfo[T, DateTime])(implicit m: ValuesMap): DateTime = m(ci)
	protected implicit def columnToString(ci: ColumnInfo[T, String])(implicit m: ValuesMap): String = m(ci)
	protected implicit def columnToBigDecimal(ci: ColumnInfo[T, BigDecimal])(implicit m: ValuesMap): BigDecimal = m(ci)
	protected implicit def columnToBigInteger(ci: ColumnInfo[T, BigInt])(implicit m: ValuesMap): BigInt = m(ci)
	protected implicit def columnToFloat(ci: ColumnInfo[T, Float])(implicit m: ValuesMap): Float = m(ci)
	protected implicit def columnToDouble(ci: ColumnInfo[T, Double])(implicit m: ValuesMap): Double = m(ci)

	protected implicit def columnTraversableManyToManyToSet[T, F](ci: ColumnInfoTraversableManyToMany[T, F])(implicit m: ValuesMap): Set[F] = m(ci).toSet
	protected implicit def columnTraversableManyToManyToList[T, F](ci: ColumnInfoTraversableManyToMany[T, F])(implicit m: ValuesMap): List[F] = m(ci).toList

	protected implicit def columnManyToOneToValue[T, F](ci: ColumnInfoManyToOne[T, F])(implicit m: ValuesMap): F = m(ci)

	protected implicit def columnTraversableOneToManyList[T, E](ci: ColumnInfoTraversableOneToMany[T, E])(implicit m: ValuesMap): List[E] = m(ci).toList
	protected implicit def columnTraversableOneToManySet[T, E](ci: ColumnInfoTraversableOneToMany[T, E])(implicit m: ValuesMap): Set[E] = m(ci).toSet

	protected implicit def columnOneToOne[F](ci: ColumnInfoOneToOne[_, F])(implicit m: ValuesMap): F = m(ci)
	protected implicit def columnOneToOneReverse[F](ci: ColumnInfoOneToOneReverse[_, F])(implicit m: ValuesMap): F = m(ci)
}

abstract class SimpleEntity[T](table: String, clz: Class[T]) extends Entity[AnyRef, T](table, clz) {
	def this(clz: Class[T]) = this(clz.getSimpleName, clz)
}
