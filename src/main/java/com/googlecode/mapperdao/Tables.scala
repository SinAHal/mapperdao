package com.googlecode.mapperdao

/**
 * mapping tables to entities
 *
 * @author kostantinos.kougios
 *
 * 12 Jul 2011
 */

case class Table[PC, T](name: String, columnInfosPlain: List[ColumnInfoBase[T, _]], extraColumnInfosPersisted: List[ColumnInfoBase[T with PC, _]], val unusedPKs: List[UnusedColumn[T]]) {

	val columns: List[ColumnBase] = columnInfosPlain.map(_.column) ::: extraColumnInfosPersisted.map(_.column)
	// the primary keys for this table
	val primaryKeys: List[PK] = columns.collect {
		case pk: PK => pk
	}
	val primaryKeyColumns: List[SimpleColumn] = primaryKeys.map(_.column)
	val primaryKeysAsCommaSeparatedList = primaryKeyColumns.map(_.columnName).mkString(",")

	val simpleTypeColumns = columns.collect {
		case c: Column => c
		case pk: PK => pk
	}
	val relationshipColumns = columns.collect {
		case c: ColumnRelationshipBase[_, _] => c
	}
	val autoGeneratedColumns = simpleTypeColumns.filter(_.isAutoGenerated)
	val columnsWithoutAutoGenerated = simpleTypeColumns.filterNot(_.isAutoGenerated) ::: relationshipColumns

	val simpleTypeSequenceColumns = simpleTypeColumns.filter(_.isSequence)
	val simpleTypeAutoGeneratedColumns = simpleTypeColumns.filter(_.isAutoGenerated)
	val simpleTypeNotAutoGeneratedColumns = simpleTypeColumns.filterNot(_.isAutoGenerated)

	val simpleTypeColumnInfos = columnInfosPlain.collect {
		case ci: ColumnInfo[T, _] => ci
	}

	val relationshipColumnInfos = columnInfosPlain.collect {
		case ci: ColumnInfoRelationshipBase[T, _, _, _] => ci
	}

	val oneToOneColumns: List[OneToOne[Any, Any]] = columns.collect {
		case c: OneToOne[Any, Any] => c
	}

	val oneToOneReverseColumns: List[OneToOneReverse[Any, Any]] = columns.collect {
		case c: OneToOneReverse[Any, Any] => c
	}

	val oneToManyColumns: List[OneToMany[Any, Any]] = columns.collect {
		case c: OneToMany[Any, Any] => c
	}
	val manyToOneColumns: List[ManyToOne[_, _]] = columns.collect {
		case mto: ManyToOne[_, _] => mto
	}
	val manyToOneColumnsFlattened: List[Column] = columns.collect {
		case ManyToOne(columns: List[Column], _) => columns
	}.flatten

	val manyToManyColumns: List[ManyToMany[Any, Any]] = columns.collect {
		case c: ManyToMany[Any, Any] => c
	}

	val oneToOneColumnInfos: List[ColumnInfoOneToOne[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOne[T, _, _] => c
	}
	val oneToOneReverseColumnInfos: List[ColumnInfoOneToOneReverse[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOneReverse[T, _, _] => c
	}

	val oneToManyColumnInfos: List[ColumnInfoTraversableOneToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[T, _, _] => c
	}
	val manyToOneColumnInfos: List[ColumnInfoManyToOne[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoManyToOne[T, _, _] => c
	}
	val manyToManyColumnInfos: List[ColumnInfoTraversableManyToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, _, _] => c
	}

	val columnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T, _]] = columnInfosPlain.map(ci => (ci.column, ci)).toMap
	val pcColumnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T with PC, _]] = extraColumnInfosPersisted.map(ci => (ci.column, ci)).toMap

	val manyToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableManyToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, _, _] => (c.column, c)
	}.toMap

	val oneToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableOneToMany[T, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[T, _, _] => (c.column, c)
	}.toMap

	def toListOfPrimaryKeyValues(o: T): List[Any] = toListOfPrimaryKeyAndValueTuples(o).map(_._2)
	def toListOfPrimaryKeyAndValueTuples(o: T): List[(PK, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)
	def toListOfPrimaryKeySimpleColumnAndValueTuples(o: T): List[(SimpleColumn, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)
	def toListOfUnusedPrimaryKeySimpleColumnAndOptionValueTuples(o: T): List[(UnusedColumn[T], Option[Any])] =
		unusedPKs.map { u =>
			(u, u.valueExtractor(o))
		}
	def toListOfUnusedPrimaryKeySimpleColumnAndValueTuples(o: T): List[(UnusedColumn[T], Any)] =
		toListOfUnusedPrimaryKeySimpleColumnAndOptionValueTuples(o).filterNot(_._2 == None).map(t => (t._1, t._2.get))

	def toListOfColumnAndValueTuples[CB <: ColumnBase](columns: List[CB], o: T): List[(CB, Any)] = columns.map { c =>
		val ctco = columnToColumnInfoMap.get(c)
		if (ctco.isDefined) {
			if (o == null) (c, null) else (c, ctco.get.columnToValue(o))
		} else {
			o match {
				case pc: T with PC =>
					val ci = pcColumnToColumnInfoMap(c)
					(c, ci.columnToValue(pc))
				case null => (c, null)
			}
		}
	}

	def toListOfColumnAndValueTuplesForUnusedKeys(o: T): List[(ColumnBase, Any)] = toListOfColumnAndValueTuplesForUnusedKeys(unusedPKs, o)
	def toListOfColumnAndValueTuplesForUnusedKeys(columns: List[UnusedColumn[T]], o: T): List[(ColumnBase, Any)] =
		columns
			.map { c => (c, c.valueExtractor(o)) }
			.filter(_._2.isDefined)
			.map { case (c, vo) => (c, vo.get) }

	def toColumnAndValueMap(columns: List[ColumnBase], o: T): Map[ColumnBase, Any] = columns.map { c => (c, columnToColumnInfoMap(c).columnToValue(o)) }.toMap
	def toPCColumnAndValueMap(columns: List[ColumnBase], o: T with PC): Map[ColumnBase, Any] = columns.map { c => (c, pcColumnToColumnInfoMap(c).columnToValue(o)) }.toMap

	def toColumnAliasAndValueMap(columns: List[ColumnBase], o: T): Map[String, Any] = toColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))
	def toPCColumnAliasAndValueMap(columns: List[ColumnBase], o: T with PC): Map[String, Any] = toPCColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))
}

case class LinkTable(name: String, left: List[Column], right: List[Column])
