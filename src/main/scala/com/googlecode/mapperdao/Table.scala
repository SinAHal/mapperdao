package com.googlecode.mapperdao

import com.googlecode.mapperdao.exceptions.ExpectedPersistedEntityException

/**
 * mapping tables to entities
 *
 * this is internal mapperdao API.
 *
 * @author kostantinos.kougios
 *
 *         12 Jul 2011
 */

case class Table[ID, PC <: DeclaredIds[ID], T](
	name: String,
	columnInfosPlain: List[ColumnInfoBase[T, _]],
	extraColumnInfosPersisted: List[ColumnInfoBase[T with PC, _]],
	val unusedPKColumnInfos: List[ColumnInfoBase[Any, Any]]
) {

	val columns: List[ColumnBase] = extraColumnInfosPersisted.map(_.column) ::: columnInfosPlain.map(_.column)
	// the primary keys for this table
	val primaryKeys: List[PK] = columns.collect {
		case pk: PK => pk
	}
	val unusedPKs = unusedPKColumnInfos.map {
		case ci: ColumnInfo[Any, Any] => List(ci.column)
		case ci: ColumnInfoManyToOne[Any, Any, Any, Any] => ci.column.columns
		case ci: ColumnInfoTraversableOneToMany[Any, Any, Any, Any, Any, Any] => ci.column.columns
		case ci: ColumnInfoOneToOne[Any, Any, Any, Any] => ci.column.columns
	}.flatten

	val primaryKeysAndUnusedKeys = primaryKeys ::: unusedPKs
	val primaryKeysSize = primaryKeysAndUnusedKeys.size

	val primaryKeyColumnInfosForT = columnInfosPlain.collect {
		case ci@ColumnInfo(_: PK, _, _) => ci
	}

	val primaryKeyColumnInfosForTWithPC = extraColumnInfosPersisted.collect {
		case ci@ColumnInfo(_: PK, _, _) => ci
	}

	val primaryKeysAsColumns = primaryKeys.map(k => Column(k.name, k.tpe)).toSet

	val primaryKeysAsCommaSeparatedList = primaryKeys.map(_.name).mkString(",")

	val simpleTypeColumns: List[SimpleColumn] = columns.collect {
		case c: Column => c
		case pk: PK => pk
	}
	val relationshipColumns = columns.collect {
		case c: ColumnRelationshipBase[_, _, _] => c
	}
	val autoGeneratedColumns = simpleTypeColumns.filter(_.isAutoGenerated)
	val autoGeneratedColumnNamesArray = autoGeneratedColumns.map(_.name).toArray
	val columnsWithoutAutoGenerated = simpleTypeColumns.filterNot(_.isAutoGenerated) ::: relationshipColumns

	val simpleTypeSequenceColumns = simpleTypeColumns.filter(_.isSequence)
	val simpleTypeAutoGeneratedColumns = simpleTypeColumns.filter(_.isAutoGenerated)
	val simpleTypeNotAutoGeneratedColumns = simpleTypeColumns.filterNot(_.isAutoGenerated)

	val simpleTypeColumnInfos = columnInfosPlain.collect {
		case ci: ColumnInfo[T, _] => ci
	}

	val allRelationshipColumnInfos = columnInfosPlain.collect {
		case ci: ColumnInfoRelationshipBase[T, _, _, _, _] => ci
	}

	val allRelationshipColumnInfosSet = allRelationshipColumnInfos.toSet

	def relationshipColumnInfos(skip: Set[ColumnInfoRelationshipBase[_, _, _, _, _]]) = if (skip.isEmpty) {
		allRelationshipColumnInfos
	} else allRelationshipColumnInfos.filterNot(skip(_))

	val oneToOneColumns: List[OneToOne[Any, DeclaredIds[Any], Any]] = columns.collect {
		case c: OneToOne[Any, DeclaredIds[Any], Any] => c
	}

	val oneToOneReverseColumns: List[OneToOneReverse[Any, DeclaredIds[Any], Any]] = columns.collect {
		case c: OneToOneReverse[Any, DeclaredIds[Any], Any] => c
	}

	val oneToManyColumns: List[OneToMany[Any, DeclaredIds[Any], Any]] = columns.collect {
		case c: OneToMany[Any, DeclaredIds[Any], Any] => c
	}
	val manyToOneColumns: List[ManyToOne[Any, DeclaredIds[Any], Any]] = columns.collect {
		case mto: ManyToOne[Any, DeclaredIds[Any], Any] => mto
	}
	val manyToOneColumnsFlattened: List[Column] = columns.collect {
		case ManyToOne(columns: List[Column], _) => columns
	}.flatten

	val manyToManyColumns: List[ManyToMany[Any, DeclaredIds[Any], Any]] = columns.collect {
		case c: ManyToMany[Any, DeclaredIds[Any], Any] => c
	}

	val oneToOneColumnInfos: List[ColumnInfoOneToOne[T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOne[T, Any, DeclaredIds[Any], _] => c
	}
	val oneToOneReverseColumnInfos: List[ColumnInfoOneToOneReverse[T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoOneToOneReverse[T, Any, DeclaredIds[Any], _] => c
	}

	val oneToManyColumnInfos: List[ColumnInfoTraversableOneToMany[ID, PC, T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[ID, PC, T, Any, DeclaredIds[Any], _] => c
	}
	val manyToOneColumnInfos: List[ColumnInfoManyToOne[T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoManyToOne[T, Any, DeclaredIds[Any], _] => c
	}
	val manyToManyColumnInfos: List[ColumnInfoTraversableManyToMany[T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, Any, DeclaredIds[Any], _] => c
	}

	val columnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T, _]] = columnInfosPlain.map(ci => (ci.column, ci)).toMap
	val pcColumnToColumnInfoMap: Map[ColumnBase, ColumnInfoBase[T with PC, _]] = extraColumnInfosPersisted.map(ci => (ci.column, ci)).toMap

	val manyToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableManyToMany[T, _, _, _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableManyToMany[T, _, _, _] => (c.column, c)
	}.toMap

	val oneToManyToColumnInfoMap: Map[ColumnBase, ColumnInfoTraversableOneToMany[ID, PC, T, Any, DeclaredIds[Any], _]] = columnInfosPlain.collect {
		case c: ColumnInfoTraversableOneToMany[ID, PC, T, Any, DeclaredIds[Any], _] => (c.column, c)
	}.toMap

	def toListOfPrimaryKeyValues(o: T): List[Any] = toListOfPrimaryKeyAndValueTuples(o).map(_._2)

	def toListOfPrimaryKeyAndValueTuples(o: T): List[(PK, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)

	def toListOfPrimaryKeySimpleColumnAndValueTuples(o: T): List[(SimpleColumn, Any)] = toListOfColumnAndValueTuples(primaryKeys, o)

	def toListOfUnusedPrimaryKeySimpleColumnAndValueTuples(o: Any): List[(SimpleColumn, Any)] =
		unusedPKColumnInfos.map {
			ci =>
				ci match {
					case ci: ColumnInfo[Any, Any] =>
						List((ci.column, ci.columnToValue(o)))
					case ci: ColumnInfoManyToOne[Any, Any, DeclaredIds[Any], Any] =>
						val l = ci.columnToValue(o)
						val fe = ci.column.foreign.entity
						val pks = fe.tpe.table.toListOfPrimaryKeyValues(l)
						ci.column.columns zip pks
					case ci: ColumnInfoTraversableOneToMany[Any, DeclaredIds[Any], Any, Any, DeclaredIds[Any], Any] =>
						o match {
							case p: Persisted =>
								ci.column.columns map {
									c =>
										(c, p.mapperDaoValuesMap.columnValue[Any](c))
								}
							case _ => Nil
						}
					case ci: ColumnInfoOneToOne[Any, Any, DeclaredIds[Any], Any] =>
						val l = ci.columnToValue(o)
						val fe = ci.column.foreign.entity
						val pks = fe.tpe.table.toListOfPrimaryKeyValues(l)
						ci.column.columns zip pks

					case ci: ColumnInfoRelationshipBase[Any, Any, Any, Any, Any] => Nil
				}
		}.flatten

	def toListOfColumnAndValueTuples[CB <: ColumnBase](columns: List[CB], o: T): List[(CB, Any)] = columns.map {
		c =>
			val ctco = columnToColumnInfoMap.get(c)
			if (ctco.isDefined) {
				if (o == null) (c, null) else (c, ctco.get.columnToValue(o))
			} else {
				o match {
					case null =>
						(c, null)
					case pc: T with DeclaredIds[_] with PC =>
						val ci = pcColumnToColumnInfoMap(c)
						(c, ci.columnToValue(pc))
					case t: T => throw new ExpectedPersistedEntityException(t)
				}
			}
	}

	def toColumnAndValueMap(columns: List[ColumnBase], o: T): Map[ColumnBase, Any] = columns.map { c => (c, columnToColumnInfoMap(c).columnToValue(o)) }.toMap

	def toPCColumnAndValueMap(columns: List[ColumnBase], o: T with PC): Map[ColumnBase, Any] = columns.map { c => (c, pcColumnToColumnInfoMap(c).columnToValue(o)) }.toMap

	def toColumnAliasAndValueMap(columns: List[ColumnBase], o: T): Map[String, Any] = toColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))

	def toPCColumnAliasAndValueMap(columns: List[ColumnBase], o: T with PC): Map[String, Any] = toPCColumnAndValueMap(columns, o).map(e => (e._1.alias, e._2))

	val selectColumns = simpleTypeColumns ::: manyToOneColumns.map(_.columns).flatten ::: oneToOneColumns.map(_.selfColumns).flatten
	val distinctSelectColumnsForSelect = (selectColumns ::: unusedPKs).distinct
}

case class LinkTable(name: String, left: List[Column], right: List[Column])
