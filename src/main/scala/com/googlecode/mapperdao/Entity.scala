package com.googlecode.mapperdao

import com.googlecode.mapperdao.internal._
import com.googlecode.mapperdao.schema.{Column, ColumnInfo, ColumnInfoManyToOne, ColumnInfoOneToOne, ColumnInfoOneToOneReverse, ColumnInfoTraversableManyToMany, ColumnInfoTraversableOneToMany, LinkTable, ManyToMany, ManyToOne, OneToMany, OneToOne, OneToOneReverse, PK, Schema, TypeRef, _}

import scala.annotation.unchecked.uncheckedVariance
import scala.collection.JavaConverters.iterableAsScalaIterableConverter
import scala.reflect.ClassTag

/**
 * the main class that must be inherited to create entities.
 *
 * Please see https://code.google.com/p/mapperdao/wiki/DiffBetweenNaturalAndSurrogateKeys
 *
 * @param table	the name of the table for this entity
 * @param clz	the class that is mapped to the table.
 * @tparam ID	the type of the id of this entity, i.e. Int if the entity has an integer primary key.
 * @tparam PC	the trait that maps to the primary key type, i.e. SurrogateIntId or NaturalIntId for Int primary keys.
 *               One of the predefined traits can be used, or i.e. a trait that extends DeclaredIds[(Long, String)] for
 *               a primary key with 2 columns, a long and a string.
 * @tparam T	the type of the domain class
 *
 * @example {{{

case class JobPosition(var name: String)

object JobPositionEntity extends Entity[Int,SurrogateIntId, JobPosition] {
        val id = key("id") autogenerated (_.id)
        val name = column("name") to (_.name)

        def constructor(implicit m:ValuesMap) = new JobPosition(name) with Stored {
                val id: Int = JobPositionEntity.id
        }
}
}}}
 *
 * @author kostantinos.kougios
 *
 *         13 Aug 2011
 */

abstract class Entity[ID, +PC <: Persisted, T](val table: String, val clz: Class[T]) extends EntityBase[ID, T] with EntityImplicits[ID, T]
{
	private[mapperdao] val entityId = internal.nextId

	/**
	 * example:
	 *
	 * override val databaseSchema = Schema("myschema")
	 */
	def databaseSchema: Option[Schema] = None

	if (clz == null) throw new NullPointerException("clz can't be null")
	if (table == null) throw new NullPointerException("table can't be null")

	/**
	 * declares the extra trait that will be mixed into every persisted instance
	 * of T. So T becomes T with Stored when it is persisted.
	 */
	type Stored = (PC@uncheckedVariance)

	def this(table: String)(implicit m: ClassTag[T]) = this(table, m.runtimeClass.asInstanceOf[Class[T]])

	def this()(implicit m: ClassTag[T]) = this(m.runtimeClass.getSimpleName, m.runtimeClass.asInstanceOf[Class[T]])

	/**
	 * overriding any of these entity-constructors is mandatory. These
	 * should return an instance of T with PC, i.e.
	 * an instance of Product with SurrogateIntId
	 */
	def constructor(implicit m: ValuesMap): T with Stored

	def constructor(implicit data: Option[_], m: ValuesMap): T with Stored = constructor(m)

	private[mapperdao] def init() {}

	/**
	 * some internal mutable state, it mutates only during Entity declarations. Having those
	 * helps so that Entities don't declare the same columns in 2 places,i.e. we don't
	 * need a "*" method with all columns.
	 */
	private var persistedColumns = List[ColumnInfoBase[T with DeclaredIds[ID], _]]()
	private var columns = List[ColumnInfoBase[T, _]]()
	private var onlyForQueryColumns = List[ColumnInfoBase[T, _]]()
	private val unusedPKs = new LazyActions[ColumnInfoBase[Any, Any]]
	private[mapperdao] lazy val tpe = {
		val con: (PersistedDetails, Option[_], ValuesMap) => T with Persisted = (pd, d, m) => {
			// construct the object
			val o = constructor(d, m)
			// set the values map
			o.mapperDaoInit(m, pd)
			o
		}
		EntityType[ID, T](clz, con, new Table[ID, T](databaseSchema, table, columns.reverse, persistedColumns, unusedPKs.executeAll.reverse), onlyForQueryColumns)
	}

	override def hashCode = table.hashCode

	override def equals(o: Any) = o match {
		case e: Entity[_, _, _] => table == e.table && clz == e.clz
		case _ => false
	}

	override def toString = "%s(%s,%s)".format(getClass.getSimpleName, table, clz.getName)

	private[mapperdao] override def keysDuringDeclaration = persistedColumns.collect {
		case ColumnInfo(pk: PK, _, _) => pk
	} ::: columns.collect {
		case ColumnInfo(pk: PK, _, _) => pk
	}

	/**
	 * converts a function T=>Option[F] to T=>F
	 */
	private def optionToValue[T, F](columnToValue: T => Option[F]): T => F = (t: T) => columnToValue(t).getOrElse(null.asInstanceOf[F])

	/**
	 * declare any primary keys that are not used for any mappings. This is especially
	 * useful in one-to-many relationships, where the many part doesn't have it's
	 * own primary key. In that case, some other column(s) can act as a primary
	 * key so that mapperdao knows how to update/delete those.
	 */
	protected def declarePrimaryKey[V](ci: ColumnInfo[T, V]) {
		unusedPKs(() => ci.asInstanceOf[ColumnInfoBase[Any, Any]])
	}

	protected def declarePrimaryKey[V, FID, F](ci: ColumnInfoManyToOne[T, FID, F]) {
		unusedPKs(() => ci.asInstanceOf[ColumnInfoBase[Any, Any]])
	}

	protected def declarePrimaryKey[V, FID, F](ci: ColumnInfoOneToOne[T, FID, F]) {
		unusedPKs(() => ci.asInstanceOf[ColumnInfoBase[Any, Any]])
	}

	/**
	 * to avoid StackOverflow exceptions due to cyclic-referenced entities, we pass
	 * this as by-name param
	 */
	protected def declarePrimaryKey[FID, F](ci: => ColumnInfoTraversableOneToMany[FID, F, ID, T]) = {
		unusedPKs(() => ci.asInstanceOf[ColumnInfoBase[Any, Any]])
		new ColumnInfoTraversableOneToManyDeclaredPrimaryKey(ci)
	}

	/**
	 * dsl for declaring columns
	 */
	private var aliasCnt = 0

	private def createAlias(clz: Class[_]) = {
		aliasCnt += 1
		tableLower + ":" + aliasCnt
	}

	/**
	 * primary key declarations. use like this:
	 *
	 * val id=key("id") autogenerated (_.id)
	 * or
	 * val id=key("id") to (_.id)
	 * or
	 * val id=key("id") sequence("mySequence") autogenerated (_.id)
	 */
	protected def key(column: String) = new PKBuilder(column)

	protected class PKBuilder(columnName: String)
	{
		private var seq: Option[String] = None

		def to[V](columnToValue: T => V)(implicit m: Manifest[V]): ColumnInfo[T, V] = {
			val tpe = m.runtimeClass.asInstanceOf[Class[V]]
			var ci = ColumnInfo(PK(Entity.this, columnName, false, None, m.runtimeClass), columnToValue, tpe)
			columns ::= ci
			ci
		}

		def sequence(seq: String) = {
			this.seq = Some(seq)
			this
		}

		def sequence(seq: Option[String]) = {
			this.seq = seq
			this
		}

		def autogenerated[V](columnToValue: T with Stored => V)(implicit m: Manifest[V]): ColumnInfo[T with DeclaredIds[ID], V] = {
			val tpe = m.runtimeClass.asInstanceOf[Class[V]]
			var ci = ColumnInfo(PK(Entity.this, columnName, true, seq, m.runtimeClass), columnToValue, tpe).asInstanceOf[ColumnInfo[T with DeclaredIds[ID], V]]
			persistedColumns ::= ci
			ci
		}
	}

	/**
	 * simple column declarations, use as
	 *
	 * val title=column("title") to (_.title)
	 */
	protected def column(column: String) = new ColumnBuilder(column)

	protected class ColumnBuilder(column: String)
		extends OnlyForQueryDefinition
	{
		def to[V](columnToValue: T => V)(implicit m: ClassTag[V]): ColumnInfo[T, V] = {
			val tpe = m.runtimeClass.asInstanceOf[Class[V]]
			val ci = ColumnInfo[T, V](Column(Entity.this, column, tpe), columnToValue, tpe)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def option[V](columnToValue: T => Option[V])(implicit m: ClassTag[V]): ColumnInfo[T, V] = to(optionToValue(columnToValue))
	}

	/**
	 * many-to-many, examples
	 *
	 * val attributes=manytomany(AttributeEntity) to (_.attributes)
	 * or, to override the default naming convention
	 * val attributes=manytomany(AttributeEntity) join("Product_To_Attributes","p_id","a_id") to (_.attributes)
	 */
	protected def manytomany[FID, FT](referenced: EntityBase[FID, FT]) = new ManyToManyBuilder(referenced, false)

	protected def manytomanyreverse[FID, FT](referenced: EntityBase[FID, FT]) = new ManyToManyBuilder(referenced, true)

	protected class ManyToManyBuilder[FID, FT](referenced: EntityBase[FID, FT], reverse: Boolean)
		extends GetterDefinition with OnlyForQueryDefinition
	{
		if (referenced == null) throw new NullPointerException("referenced entity can't be null")

		val clz = Entity.this.clz
		private var linkTable = if (reverse) referenced.table + "_" + table else table + "_" + referenced.table
		private var schemaO: Option[Schema] = referenced.databaseSchema

		/**
		 * create the columns based on default naming conventions
		 */
		private var leftColumns = keysDuringDeclaration.map(pk => tableLower + "_" + pk.name)
		private var rightColumns = referenced match {
			case ee: ExternalEntity[_, _] => List(referenced.tableLower + "_id")
			case _ => referenced.keysDuringDeclaration.map(pk => referenced.tableLower + "_" + pk.name)
		}

		if (leftColumns.isEmpty) throw new IllegalStateException("%s didn't declare any primary keys or pk declaration before this declaration".format(clz))
		if (rightColumns.isEmpty) throw new IllegalStateException("%s didn't declare any primary keys or pk declaration".format(referenced.clz))

		def join(linkTable: String, leftColumn: String, rightColumn: String) = {
			this.linkTable = linkTable
			this.leftColumns = List(leftColumn)
			this.rightColumns = List(rightColumn)
			this
		}

		def join(linkTable: String, leftColumns: List[String], rightColumns: List[String]) = {
			this.linkTable = linkTable
			this.leftColumns = leftColumns
			this.rightColumns = rightColumns
			this
		}

		def schema(s: Schema) = {
			schemaO = Option(s)
			this
		}

		def to(columnToValue: T => Traversable[FT]): ColumnInfoTraversableManyToMany[T, FID, FT] = {
			if (keysDuringDeclaration.size != leftColumns.size) throw new IllegalStateException("join is invalid, left part keys %s and right part %s".format(keysDuringDeclaration, leftColumns))
			if (referenced.keysDuringDeclaration.size != rightColumns.size) throw new IllegalStateException("join is invalid, left part keys %s and right part %s".format(referenced.keysDuringDeclaration, rightColumns))

			val left = keysDuringDeclaration zip leftColumns
			val right = referenced.keysDuringDeclaration zip rightColumns

			val ci = ColumnInfoTraversableManyToMany[T, FID, FT](
				ManyToMany(
					Entity.this,
					LinkTable(
						schemaO,
						linkTable,
						left.map {
							case (k, c) =>
								Column(Entity.this, c, k.tpe)
						}, right.map {
							case (k, c) =>
								Column(Entity.this, c, k.tpe)
						}),
					TypeRef(createAlias(referenced.clz), referenced)
				),
				columnToValue,
				getterMethod
			)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def tojava(columnToValue: T => java.lang.Iterable[FT]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((ctv: T) => columnToValue(ctv).asScala)

		def tostring(columnToValue: T => Traversable[String]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(StringValue(_)).asInstanceOf[Traversable[FT]]
			})

		def toint(columnToValue: T => Traversable[Int]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(IntValue(_)).asInstanceOf[Traversable[FT]]
			})

		def tofloat(columnToValue: T => Traversable[Float]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(FloatValue(_)).asInstanceOf[Traversable[FT]]
			})

		def todouble(columnToValue: T => Traversable[Double]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(DoubleValue(_)).asInstanceOf[Traversable[FT]]
			})

		def tolong(columnToValue: T => Traversable[Long]): ColumnInfoTraversableManyToMany[T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(LongValue(_)).asInstanceOf[Traversable[FT]]
			})
	}

	/**
	 * one-to-one, examples:
	 *
	 * val inventory=onetoone(InventoryEntity) to (_.inventory)
	 * or
	 * val inventory=onetoone(InventoryEntity) option (_.inventory)
	 */
	protected def onetoone[FID, FT](referenced: EntityBase[FID, FT]) = new OneToOneBuilder(referenced)

	protected class OneToOneBuilder[FID, FT](referenced: EntityBase[FID, FT])
		extends OnlyForQueryDefinition
	{
		if (referenced == null) throw new NullPointerException("referenced entity can't be null")

		private var cols = referenced.keysDuringDeclaration.map {
			k =>
				referenced.tableLower + "_" + k.name
		}

		def foreignkey(fk: String) = {
			cols = List(fk)
			this
		}

		def foreignkeys(cs: List[String]) = {
			cols = cs
			this
		}

		def to(columnToValue: T => FT): ColumnInfoOneToOne[T, FID, FT] = {
			val fPKs = referenced.keysDuringDeclaration
			if (fPKs.size != cols.size) throw new IllegalStateException("keys don't match foreign keys for %s -> %s".format(cols, referenced))
			val fkeys = fPKs zip cols
			val ci = ColumnInfoOneToOne(OneToOne(Entity.this, TypeRef(createAlias(referenced.clz), referenced), fkeys.map {
				case (k, col) =>
					Column(Entity.this, col, k.tpe)
			}), columnToValue)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def option(columnToValue: T => Option[FT]): ColumnInfoOneToOne[T, FID, FT] = to(optionToValue(columnToValue))
	}

	/**
	 * one-to-one reverse, i.e.
	 * val product=onetoonereverse(ProductEntity) to (_.product)
	 */
	protected def onetoonereverse[FID, FT](referenced: EntityBase[FID, FT]) = new OneToOneReverseBuilder(referenced)

	protected class OneToOneReverseBuilder[FID, FT](referenced: EntityBase[FID, FT])
		extends GetterDefinition
		with OnlyForQueryDefinition
	{
		if (referenced == null) throw new NullPointerException("referenced entity can't be null")

		val clz = Entity.this.clz
		private var fkcols = keysDuringDeclaration.map {
			k =>
				tableLower + "_" + k.name
		}

		def foreignkey(fk: String) = {
			fkcols = List(fk)
			this
		}

		def foreignkeys(cs: List[String]) = {
			fkcols = cs
			this
		}

		def to(columnToValue: T => FT): ColumnInfoOneToOneReverse[T, FID, FT] = {
			if (keysDuringDeclaration.size != fkcols.size) throw new IllegalStateException("keys don't match foreign keys for %s -> %s".format(fkcols, referenced))
			val fkeys = keysDuringDeclaration zip fkcols
			val ci = ColumnInfoOneToOneReverse(OneToOneReverse(Entity.this, TypeRef(createAlias(referenced.clz), referenced), fkeys.map {
				case (k, col) =>
					Column(Entity.this, col, k.tpe)
			}), columnToValue, getterMethod)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def option(columnToValue: T => Option[FT]): ColumnInfoOneToOneReverse[T, FID, FT] = to(optionToValue(columnToValue))
	}

	/**
	 * one-to-many, i.e.
	 *
	 * val houses=onetomany(HouseEntity) to (_.houses)
	 */
	protected def onetomany[FID, FT](referenced: EntityBase[FID, FT]) = new OneToManyBuilder(referenced)

	protected class OneToManyBuilder[FID, FT](referenced: EntityBase[FID, FT])
		extends GetterDefinition
		with OnlyForQueryDefinition
	{
		if (referenced == null) throw new NullPointerException("referenced entity can't be null")

		val clz = Entity.this.clz
		private var fkcols = keysDuringDeclaration.map(tableLower + "_" + _.name)
		if (fkcols.isEmpty) throw new IllegalStateException("couldn't find any declared keys for %s, are keys declared before this onetomany?".format(clz))

		def foreignkey(fk: String) = {
			fkcols = List(fk)
			this
		}

		def foreignkeys(cs: List[String]) = {
			fkcols = cs
			this
		}

		def to(columnToValue: T => Traversable[FT]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] = {
			if (keysDuringDeclaration.size != fkcols.size) throw new IllegalArgumentException("foreign keys declaration not correct, foreign entity %s , declared %s".format(referenced, fkcols))
			val fkeys = keysDuringDeclaration zip fkcols
			val ci = ColumnInfoTraversableOneToMany[ID, T, FID, FT](
				OneToMany(
					Entity.this,
					TypeRef(createAlias(referenced.clz), referenced),
					fkeys.map {
						case (k, c) =>
							Column(Entity.this, c, k.tpe)
					}
				),
				columnToValue,
				getterMethod,
				Entity.this)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def tojava(columnToValue: T => java.lang.Iterable[FT]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((ctv: T) => columnToValue(ctv).asScala)

		def tostring(columnToValue: T => Traversable[String]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(StringValue(_)).asInstanceOf[Traversable[FT]]
			})

		def toint(columnToValue: T => Traversable[Int]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(IntValue(_)).asInstanceOf[Traversable[FT]]
			})

		def tofloat(columnToValue: T => Traversable[Float]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(FloatValue(_)).asInstanceOf[Traversable[FT]]
			})

		def todouble(columnToValue: T => Traversable[Double]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(DoubleValue(_)).asInstanceOf[Traversable[FT]]
			})

		def tolong(columnToValue: T => Traversable[Long]): ColumnInfoTraversableOneToMany[ID, T, FID, FT] =
			to((t: T) => {
				columnToValue(t).map(LongValue(_)).asInstanceOf[Traversable[FT]]
			})
	}

	/**
	 * many-to-one, i.e.
	 *
	 * val person=manytoone(PersonEntity) to (_.person)
	 */
	protected def manytoone[FID, FT](referenced: EntityBase[FID, FT]) = new ManyToOneBuilder(referenced)

	protected class ManyToOneBuilder[FID, FT](referenced: EntityBase[FID, FT])
		extends GetterDefinition
		with OnlyForQueryDefinition
	{
		if (referenced == null) throw new NullPointerException("referenced entity can't be null")

		val clz = Entity.this.clz
		private var fkcols = referenced.keysDuringDeclaration map {
			pk =>
				referenced.tableLower + "_" + pk.name
		}

		def foreignkey(fk: String) = {
			fkcols = List(fk)
			this
		}

		def foreignkeys(cs: List[String]) = {
			fkcols = cs
			this
		}

		def to(columnToValue: T => FT): ColumnInfoManyToOne[T, FID, FT] = {
			if (referenced.keysDuringDeclaration.size != fkcols.size) throw new IllegalArgumentException("the number of foreign columns doesn't match the number of keys for %s => %s".format(referenced.keysDuringDeclaration, fkcols))
			val keys = referenced.keysDuringDeclaration zip fkcols

			val ci = ColumnInfoManyToOne(
				ManyToOne(
					Entity.this,
					keys.map {
						case (k, c) =>
							Column(Entity.this, c, k.tpe)
					},
					TypeRef(createAlias(referenced.clz), referenced)),
				columnToValue,
				getterMethod
			)
			if (!onlyForQuery) columns ::= ci else onlyForQueryColumns ::= ci
			ci
		}

		def option(columnToValue: T => Option[FT]): ColumnInfoManyToOne[T, FID, FT] =
			to(optionToValue(columnToValue))
	}

	/**
	 * utility method to cast an entity to it's persisted type
	 *
	 * @param t     the entity
	 * @return      entity with Stored
	 */
	def toPersistedType(t: T): T with Stored = t.asInstanceOf[T with Stored]
}
