package com.googlecode.mapperdao

import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.FunSuite
import org.scalatest.matchers.ShouldMatchers
import com.googlecode.mapperdao.jdbc.Setup
import com.googlecode.mapperdao.utils.Helpers

/**
 * @author kostantinos.kougios
 *
 * 30 Jul 2012
 */
@RunWith(classOf[JUnitRunner])
class OneToOneReverseCompositeKeySuite extends FunSuite with ShouldMatchers {

	import OneToOneReverseCompositeKeySuite._
	if (database != "h2") {
		implicit val (jdbc, mapperDao, queryDao) = Setup.setupMapperDao(TypeRegistry(InventoryEntity, ProductEntity))

		// aliases
		val ie = InventoryEntity
		val pe = ProductEntity

		//		test("query") {
		//			createTables()
		//			noise
		//			noise
		//			val inserted1 = mapperDao.insert(InventoryEntity, Inventory("rc1", Product("product 1"), 5))
		//			val inserted2 = mapperDao.insert(InventoryEntity, Inventory("rc2", Product("product 2"), 6))
		//
		//			import Query._
		//			(
		//				select
		//				from ie
		//				where ie.stock === 6
		//			).toSet should be === Set(inserted2)
		//
		//			(
		//				select
		//				from ie
		//				join (ie, ie.product, pe)
		//				where pe.refCode === "rc2"
		//			).toSet should be === Set(inserted2)
		//			(
		//				select
		//				from ie
		//				join (ie, ie.product, pe)
		//				where pe.refCode === "rc2" or pe.refCode === "rc1"
		//			).toSet should be === Set(inserted1, inserted2)
		//		}

		test("create, select and delete") {
			createTables()
			noise
			noise
			val i = Inventory("ref1", Product("product 1", null), 5)
			val inserted = mapperDao.insert(InventoryEntity, i)
			inserted should be === i

			mapperDao.select(InventoryEntity, inserted.id, inserted.refCode).get should be === Inventory("ref1", Product("product 1", Inventory("ref1", Product("product 1", null), 5)), 5)

			mapperDao.delete(InventoryEntity, inserted)
			mapperDao.select(InventoryEntity, inserted.id, inserted.refCode) should be === None
		}

		test("delete associated with cascade") {
			createTables()
			noise
			noise
			val i = Inventory("ref1", Product("rc1", null), 5)
			val inserted = mapperDao.insert(InventoryEntity, i)
			val productId = Helpers.intIdOf(inserted.product)

			mapperDao.delete(DeleteConfig(propagate = true), ProductEntity, Helpers.asIntId(inserted.product))
			mapperDao.select(InventoryEntity, inserted.id, inserted.refCode) should be === None
			mapperDao.select(ProductEntity, productId) should be === None
		}

		test("update") {
			createTables()
			noise
			noise
			val i = Inventory("ref1", Product("rc1", null), 5)
			val inserted = mapperDao.insert(InventoryEntity, i)
			inserted should be === i

			val upd = inserted.copy(product = Product("rc2", null))
			val updated = mapperDao.update(InventoryEntity, inserted, upd)
			updated should be === upd

			mapperDao.select(InventoryEntity, updated.id, "ref1").get should be === Inventory("ref1", Product("rc2", Inventory("ref1", Product("rc2", null), 5)), 5)
		}

		def noise = mapperDao.insert(InventoryEntity, Inventory("ref1", Product("a nice & noisy product", null), 8))

		def createTables() =
			{
				Setup.dropAllTables(jdbc)
				Setup.queries(this, jdbc).update("ddl")
				if (Setup.database == "oracle") {
					Setup.createSeq(jdbc, "InventorySeq")
					Setup.createSeq(jdbc, "ProductSeq")
				}
			}
	}
}

object OneToOneReverseCompositeKeySuite {
	val database = Setup.database

	case class Inventory(refCode: String, product: Product, stock: Int)
	case class Product(name: String, inventory: Inventory)

	object InventoryEntity extends Entity[IntId, Inventory] {
		val id = key("id") sequence (
			if (database == "oracle") Some("InventorySeq") else None
		) autogenerated (_.id)
		val refCode = key("refCode") to (_.refCode)
		val product = onetoone(ProductEntity) to (_.product)
		val stock = column("stock") to (_.stock)

		def constructor(implicit m) = new Inventory(refCode, product, stock) with Persisted with IntId {
			val id: Int = InventoryEntity.id
		}
	}

	object ProductEntity extends Entity[IntId, Product] {
		val id = key("id") sequence (
			if (database == "oracle") Some("ProductSeq") else None
		) autogenerated (_.id)
		val name = column("name") to (_.name)
		val inventory = onetoonereverse(InventoryEntity) to (_.inventory)

		def constructor(implicit m) = new Product(name, inventory) with Persisted with IntId {
			val id: Int = ProductEntity.id
		}
	}
}
