package com.googlecode.mapperdao

import org.specs2.mutable.SpecificationWithJUnit
import com.googlecode.mapperdao.jdbc.Setup
import org.junit.runner.RunWith
import org.specs2.runner.JUnitRunner

/**
 * @author kostantinos.kougios
 *
 * 5 Sep 2011
 */
@RunWith(classOf[JUnitRunner])
class OneToOneAutogeneratedTwoWaySpec extends SpecificationWithJUnit {
	import OneToOneAutogeneratedTwoWaySpec._
	val (jdbc, driver, mapperDao) = Setup.setupMapperDao(TypeRegistry(ProductEntity, InventoryEntity))

	"delete, DeleteConfig(true)" in {
		createTables(false)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)

		mapperDao.delete(DeleteConfig(true), ProductEntity, inserted)
		jdbc.queryForInt("select count(*) from Product") must_== 0
		jdbc.queryForInt("select count(*) from Inventory") must_== 0
	}

	"delete, DeleteConfig(true,skip)" in {
		createTables(false)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)

		mapperDao.delete(DeleteConfig(true, skip = Set(ProductEntity.inventory)), ProductEntity, inserted)
		jdbc.queryForInt("select count(*) from Product") must_== 0
		jdbc.queryForInt("select count(*) from Inventory") must_== 1
	}

	"select, skip one-to-one" in {
		createTables(true)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)

		val selected = mapperDao.select(SelectConfig(skip = Set(InventoryEntity.product)), ProductEntity, List(inserted.id)).get
		selected.inventory.product must beNull
		selected.inventory must_== Inventory(null, 5)
	}

	"select, skip one-to-one-reverse" in {
		createTables(true)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)

		val selected = mapperDao.select(SelectConfig(skip = Set(ProductEntity.inventory)), ProductEntity, List(inserted.id)).get
		selected.inventory must beNull
	}

	"update to null" in {
		createTables(true)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)
		inserted.inventory = null
		val updated = mapperDao.update(ProductEntity, inserted)
		updated.inventory must_== null
		mapperDao.select(ProductEntity, inserted.id).get must_== updated
	}

	"CRUD mutable" in {
		createTables(true)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)
		inserted.inventory.stock = 8
		val updated = mapperDao.update(ProductEntity, inserted)
		updated must_== inserted
		val selected = mapperDao.select(ProductEntity, updated.id).get
		selected must_== updated

		mapperDao.delete(ProductEntity, selected)
		mapperDao.select(ProductEntity, selected.id) must beNone
	}

	"insert & select mutable" in {
		createTables(true)
		val product = Product(Inventory(null, 5), 0)
		product.inventory.product = product
		val inserted = mapperDao.insert(ProductEntity, product)
		inserted.inventory.stock must_== product.inventory.stock
		val selected = mapperDao.select(ProductEntity, inserted.id).get
		selected must_== inserted
	}

	"from null to value" in {
		createTables(true)
		val product = Product(null, 0)
		val inserted = mapperDao.insert(ProductEntity, product)
		inserted.inventory = Inventory(inserted, 5)
		val updated = mapperDao.update(ProductEntity, inserted)
		updated.inventory must_== inserted.inventory
		mapperDao.select(ProductEntity, inserted.id).get must_== updated

		mapperDao.delete(ProductEntity, updated)
		mapperDao.select(ProductEntity, updated.id) must beNone
	}

	def createTables(cascade: Boolean) =
		{
			Setup.dropAllTables(jdbc)
			Setup.queries(this, jdbc).update(if (cascade) "cascade" else "nocascade")
			Setup.database match {
				case "postgresql" =>
					Setup.createMySeq(jdbc)
				case "oracle" =>
					Setup.createMySeq(jdbc)
					Setup.oracleTrigger(jdbc, "Product")
				case _ =>
			}
		}

}

object OneToOneAutogeneratedTwoWaySpec {
	case class Inventory(var product: Product, var stock: Int) {
		override def hashCode = stock
		override def equals(v: Any) = v match {
			case i: Inventory => i.stock == stock && ((i.product == null && product == null) || (i.product != null && product != null && i.product == product))
			case _ => false
		}
		override def toString = "Inventory(%d, productId:%s)".format(stock, product match {
			case p: Product with IntId => p.id
			case p: Product => "Product(not persisted)"
			case null => null
		})
	}
	case class Product(var inventory: Inventory, val x: Int) {
		override def equals(v: Any) = v match {
			case p: Product with IntId =>
				this match {
					case tp: Product with IntId => tp.id == p.id
					case _ => false
				}
			case _ => false
		}
	}

	object InventoryEntity extends SimpleEntity[Inventory](classOf[Inventory]) {
		val product = onetoone(ProductEntity) to (_.product)
		val stock = column("stock") to (_.stock)

		def constructor(implicit m) = new Inventory(product, stock) with Persisted
	}

	val sequence = Setup.database match {
		case "postgresql" | "oracle" => Some("myseq")
		case _ => None
	}
	object ProductEntity extends Entity[IntId, Product](classOf[Product]) {
		val id = key("id") sequence (sequence) autogenerated (_.id)
		val inventory = onetoonereverse(InventoryEntity) to (_.inventory)
		val x = column("x") to (_.x)

		def constructor(implicit m) = new Product(inventory, x) with IntId with Persisted {
			val id: Int = ProductEntity.id
		}
	}

}