package com.googlecode.mapperdao

import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.matchers.ShouldMatchers
import org.scalatest.FunSuite
import com.googlecode.mapperdao.jdbc.Setup

/**
 * @author kostantinos.kougios
 *
 * 7 Feb 2012
 */
@RunWith(classOf[JUnitRunner])
class UseCaseFileSystemSuite extends FunSuite with ShouldMatchers {
	import UseCaseFileSystemSuite._

	val (jdbc, mapperDao, queryDao) = Setup.setupMapperDao(TypeRegistry(DirectoryEntity, FileEntity))

	if (Setup.database == "h2") {
		test("integration") {
			createTables()
			val parent = Directory("parent_dir", None, Nil)
			val dir = Directory("my_dir", Some(parent), Nil)
			val inserted = mapperDao.insert(DirectoryEntity, dir)
			val toUpdate = inserted.copy(nodes = List(File("file1.txt", inserted, "text file")))
			val updated = mapperDao.update(DirectoryEntity, inserted, toUpdate)
			updated should be === toUpdate
		}

		test("persist directory") {
			createTables()
			val dir = Directory("my_dir", None, Nil)
			val inserted = mapperDao.insert(DirectoryEntity, dir)
			dir should be === inserted
		}

		test("persist directory with parent") {
			createTables()
			val parent = Directory("parent_dir", None, Nil)
			val dir = Directory("my_dir", Some(parent), Nil)
			val inserted = mapperDao.insert(DirectoryEntity, dir)
			dir should be === inserted
		}
	}

	def createTables() {
		Setup.dropAllTables(jdbc)
		val queries = Setup.queries(this, jdbc)
		queries.update("ddl")
	}
}

object UseCaseFileSystemSuite {

	/**
	 * Domain model classes
	 */
	abstract class Node(val uri: String)
	case class Directory(override val uri: String, val parent: Option[Directory], nodes: List[Node]) extends Node(uri)

	abstract class FileNode(override val uri: String, val parent: Directory) extends Node(uri)
	case class File(override val uri: String, override val parent: Directory, fileType: String) extends FileNode(uri, parent)

	/**
	 * Entities
	 */

	/**
	 * the parent entity of all nodes, used only for subclassing. It contains all common columns
	 */
	abstract class NodeEntity[T <: Node](clz: Class[T]) extends Entity[IntId, T](clz) {

		val id = key("id") autogenerated (_.id)
		val uri = column("uri") to (_.uri)
	}

	object DirectoryEntity extends NodeEntity(classOf[Directory]) {
		// we need to map each note seperatelly. Lets start with files
		val files = onetomany(FileEntity) foreignkey ("parent_id") to (_.nodes.collect {
			// we'll collect only the files
			case f: File => f
		})

		val parent = manytoone(this) foreignkey ("parent_id") option (_.parent)
		def constructor(implicit m) = new Directory(uri, parent, files) with Persisted with IntId {
			val id: Int = DirectoryEntity.id
		}
	}

	abstract class FileNodeEntity[T <: FileNode](clz: Class[T]) extends NodeEntity(clz) {
		val parent = manytoone(DirectoryEntity) foreignkey ("parent_id") to (_.parent)
	}

	object FileEntity extends FileNodeEntity(classOf[File]) {
		val fileType = column("fileType") to (_.fileType)

		def constructor(implicit m) = new File(uri, parent, fileType) with Persisted with IntId {
			val id: Int = FileEntity.id
		}
	}
}