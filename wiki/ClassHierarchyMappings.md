Class hierarchies can be stored in 1 table or 1 table per class.

### Store all in 1 table ###

A mapping for all the entities can be created and 1 column has to be dedicated to indicate the actual class that has to be recreated.
Lets start with the domain model. Assuming we need to have reminders for events, we could have the following classes:

```
abstract class Reminder(val remindUsers: Set[User])

class Daily(hourOfDay: Short, override val remindUsers: Set[User]) extends Reminder(remindUsers)
class Weekly(hourOfDay: Short, dayOfWeek: Short, override val remindUsers: Set[User]) extends Reminder(remindUsers)
class RemindOnce(time: DateTime, override val remindUsers: Set[User]) extends Reminder(remindUsers)
```

The table that we will store all the hierarchy of classes (postgresql):

```
ï»¿create table Reminder (
	id serial,
	type smallint not null,
	hourOfDay smallint not null,
	dayOfWeek smallint not null,
	time timestamp with time zone,
...
	primary key (id)
)
```

Please note we will use the `type` column to define which subclass will be used. If type=0 then `Daily` will be used, 1 for `Weekly` and 2 for `RemindOnce`.

Other than that, we have columns that will store all the data for the hierarchy.

And now we can see the mapping itself. Because we store/retrieve 3 different classes, the mapping is a bit complex but it all makes sense. The column mappings must check what type they map and return the correct value (or -1/null if the column is not used by a specific subclass). And the constructor has to use the `type` to figure out which subclass to instantiate:

```
object ReminderEntity extends Entity[Int,SurrogateIntId, Reminder] {
	val id = key("id") autogenerated (_.id)
	// we will map the inheritance into the "type" column 
	val t = column("type") to {
		case _: Daily => 0 // type=0 for Daily class
		case _: Weekly => 1 // type=1 for Weekly class
		case _: RemindOnce => 2 // type=2 for Monthly class
	})
	val hourOfDay = column("hourOfDay") to {
		case daily: Daily => daily.hourOfDay
		case weekly: Weekly => weekly.hourOfDay
		case _: RemindOnce => -1
	}
	val dayOfWeek = column("dayOfWeek") to {
		case _: Daily => -1
		case weekly: Weekly => weekly.dayOfWeek
		case _: RemindOnce => -1
	}
	val time = column("time") to {
		case _: Daily => null
		case _: Weekly => null
		case remindOnce: RemindOnce => remindOnce.time
	}

	val remindUsers = manytomany(UserEntity) to (_.remindUsers)

	def constructor(implicit m) = m(t) match {
		case 0 => new Daily(hourOfDay, remindUsers) with Stored {
			val id:Int = ReminderEntity.id
		}
		case 1 => new Weekly(hourOfDay, dayOfWeek, remindUsers) with Stored {
			val id:Int = ReminderEntity.id
		}
		case 2 => new RemindOnce(time, remindUsers) with Stored {
			val id:Int = ReminderEntity.id
		}
	}
}
```

[example](https://code.google.com/p/mapperdao/source/browse/src/test/java/com/googlecode/mapperdao/MultipleInheritance1TableSuite.scala)

### 1 table per subclass ###

There are different ways to map those i.e. the domain class hierarchy can be mapped with an entity hierarchy. 1 mapping per subclass should be created but it can extend an abstract base mapping.

A use case follows. We need to map a domain class consisting of Directories, Files and Archives. Each of them can have a parent directory as parent and though they all share some properties, they also have special properties of their own.

Lets review the domain classes first:
```
abstract class Node(val uri: String)

// parent directory for a Directory is optional as the root directories dont have a parent
case class Directory(override val uri: String, val parent: Option[Directory], nodes: List[Node]) extends Node(uri)

// for file nodes, parent directory should always be present
abstract class FileNode(override val uri: String, val parent: Directory) extends Node(uri)
case class File(override val uri: String, override val parent: Directory, fileType: String) extends FileNode(uri, parent)
case class Archive(override val uri: String, override val parent: Directory, zipType: String) extends FileNode(uri, parent)
```

We'll create 3 tables to store them:

```
create table Directory (
	id serial not null,
	uri varchar(150) not null,
	parent_id int, -- a directory but can be null => no parent
	primary key (id),
	foreign key (parent_id) references Directory(id) on delete cascade on update cascade
)

create table File (
	id serial not null,
	uri varchar(150) not null,
	parent_id int not null, -- a directory
	fileType varchar(10) not null,
	primary key (id),
	foreign key (parent_id) references Directory(id) on delete cascade on update cascade
)

create table Archive (
	id serial not null,
	uri varchar(150) not null,
	parent_id int not null, -- a directory
	zipType varchar(10) not null,
	primary key (id),
	foreign key (parent_id) references Directory(id) on delete cascade on update cascade
)

```

And now time for the mappings. We'll use hierarchy for the entity declarations as we  did for the domain declarations :

```
/**
 * the parent entity of all nodes, used only for subclassing. It contains all common columns
 */
abstract class NodeEntity[T <: Node](clz: Class[T]) extends Entity[Int,SurrogateIntId, T](clz) {

	val id = key("id") autogenerated (_.id)
	val uri = column("uri") to (_.uri)
}

object DirectoryEntity extends NodeEntity[Directory] {
	// we need to map each nodes seperatelly. Lets start with files
	val files = onetomany(FileEntity) foreignkey ("parent_id") to (_.nodes.collect {
		// we'll collect only the files
		case f: File => f
	})
	// and continue with the archives
	var archives = onetomany(ArchiveEntity) foreignkey ("parent_id") to (_.nodes.collect {
		// we'll collect only the archives
		case a: Archive => a
	})

	val parent = manytoone(this) foreignkey ("parent_id") option (_.parent)

	// though we map files and archives separatelly, for the domain model we need to
	// merge them into a node list:
	def constructor(implicit m) = new Directory(uri, parent, m(files).toList ++ m(archives).toList) with Stored {
		val id: Int = DirectoryEntity.id
	}
}

/**
 * this will serve the parent of all file-based nodes
**/
abstract class FileNodeEntity[T <: FileNode](clz: Class[T]) extends NodeEntity(clz) {
	val parent = manytoone(DirectoryEntity) foreignkey ("parent_id") to (_.parent)
}

object FileEntity extends FileNodeEntity(classOf[File]) {
	val fileType = column("fileType") to (_.fileType)

	def constructor(implicit m) = new File(uri, parent, fileType) with Stored {
		val id: Int = FileEntity.id
	}
}

object ArchiveEntity extends FileNodeEntity(classOf[Archive]) {
	val zipType = column("zipType") to (_.zipType)

	def constructor(implicit m) = new Archive(uri, parent, zipType) with Stored {
		val id: Int = ArchiveEntity.id
	}
}
```