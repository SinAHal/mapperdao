MapperDao supports both natural and surrogate keys. Composite keys are also supported along with autogenerated keys.

For mappings, there is a distinction when using a surrogate autogenerated key and when using a natural key or a key
that is managed within the code rather than by the database.

### Entities with surrogate/generated keys ###

Entities which are mapped to tables with autogenerated keys (either identities or sequences etc) acquire the key only after been persisted.
Hence mapperdao gives them an id only after storing those in the database. This means that the entity is of type T but after inserted or selected from the database, it can be T with SurrogateIntId. This is also reflected in the mappings:

```
case class JobPosition(var name: String)

object JobPositionEntity extends Entity[Int,SurrogateIntId, JobPosition] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)

	def constructor(implicit m) = new JobPosition(name) with Stored {
		val id: Int = JobPositionEntity.id
	}
}

val j=JobPosition("Scala Developer") // doesn't have an id
val inserted=mapperDao.insert(JobPositionEntity,j)
// now inserted has an id : inserted.id. inserted is a JobPosition with SurrogateIntId
```

In the above example, the in-memory instance of JobPosition initially doesn't have an id but it acquires it after been inserted
into the database. Please note the constructor method instantiates a JobPosition with SurrogateIntId.

More examples:

[SimpleEntitiesAutoGeneratedSuite.scala](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/SimpleEntitiesAutoGeneratedSuite.scala)

### Entities with natural or client-managed keys ###

For natural keys, the key can be part of the entity, i.e.

```
// company.no is the natural key for this entity
case class Company(val no: String, val name: String)
```

In this case, it's up to client code to populate the key. The mapping can be done using Entity along with the many Natural\*Id traits :

```
object CompanyEntity extends Entity[String,NaturalStringId,Company] {
	val no = key("no") to (_.no)
	val name = column("name") to (_.name)

	def constructor(implicit m) = new Company(no, name) with Stored
}
```


Examples

  * [Surrogate non-generated key](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/SimpleEntitiesSuite.scala)
  * [Natural keys](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/IntermediateImmutableEntityWithStringFKsSuite.scala)

### Composite keys ###

Those can be mapped in a similar way, i.e.

```
case class User(val name: String, val surname: String, val age: Int)

object UserEntity extends Entity[(String,String),NaturalStringAndStringIds,User] {
	val name = key("name") to (_.name)
	val surname = key("surname") to (_.surname)
	val age = column("age") to (_.age)

	def constructor(implicit m) = new User(name, surname, age) with Stored
}
```

Please note both name and surname are keys.

All kinds of relationships are supported for composite keys.

  * [Composite Natural Key](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/TwoPrimaryKeysSimpleSuite.scala)
  * [One to many with composite key](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/OneToManyCompositeKeySuite.scala)
  * [many-to-many with composite key](https://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/ManyToManyCompositeKeySuite.scala)