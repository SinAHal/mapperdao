## One To Many ##

Using `StringEntity`, `IntEntity`, `LongEntity`, `DoubleEntity`, `FloatEntity`, Sets and Lists of AnyVal types can be mapped to tables.
For example lets say that we store product tags in a separate table:

```
create table Product (
	id serial not null,
	name varchar(100) not null,
	primary key (id)
)

create table ProductTags (
	product_id int not null,
	tag varchar(30) not null,
	foreign key (product_id) references Product(id) on delete cascade
)
```

The `ProductTags` table contains only a string column and a FK that references `Product.id`.

We can map this relationship without the need for a separate domain class for the tags:

```
case class Product(name: String, tags: Set[String])

// note: TagsEntity has to be registered when setting up mapperdao
val TagsEntity = StringEntity.oneToMany("ProductTags", "tag")

object ProductEntity extends Entity[Int,SurrogateIntId, Product] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)
	val tags = onetomany(TagsEntity) tostring (_.tags)
	def constructor(implicit m) = new Product(name, tags) with Stored {
		val id: Int = ProductEntity.id
	}
}
```

There are 2 important bits for this mapping:

```
val TagsEntity = StringEntity.oneToMany("ProductTags", "tag")
```

This creates a string entity for the  `ProductTags` table. `product_id` is the foreign key column and `tag` is the string column.

```
...
val tags = onetomany(TagsEntity) tostring (_.tags)
...
```

The above code does the mapping from `tags:Set[String]` to `TagsEntity`.

Finally, we can use the entity when we query:

```
import Query._
val pe = ProductEntity
val te = TagsEntity
val q = (
	select from pe
	join (pe, pe.tags, te)
	where te.value === "tag3"
)
val results=queryDao.query(q)
... 
```

Please note that we use the `value` of the `TagEntity`:
```
...
	where te.value === "tag3"
```

[example](http://code.google.com/p/mapperdao/source/browse/src/test/scala/com/googlecode/mapperdao/OneToManySimpleTypesSuite.scala)

## ManyToMany ##

AnyVal values can also be mapped as many-to-many. Assuming a domain class of:

```
case class Product(val name: String, val categories: Set[String])
```

and a table structure of :

```
create table Product (
	id serial not null,
	name varchar(100) not null,
	primary key (id)
)
;

create table Category (
	id serial not null,
	name varchar(50) not null,
	primary key (id)
)
;

create table Product_Category (
	product_id int not null,
	category_id int not null,
	primary key (product_id,category_id),
	foreign key (product_id) references Product(id) on delete cascade,
	foreign key (category_id) references Category(id) on delete cascade
)
```

The mapping can look like:

```
// map the entity to Category table which has an id autogenerated column and a name String column
val CategoriesEntity = StringEntity.manyToManyAutoGeneratedPK("Category", "id", "name")

object ProductEntity extends Entity[Int,SurrogateIntId, Product] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)
	
	// the many-to-many mapping uses the Product_Category(product_id,category_id) intermediate table
	val categories = manytomany(CategoriesEntity) join ("Product_Category", "product_id", "category_id") tostring (_.categories)
	
	def constructor(implicit m) = new Product(name, categories) with Stored {
		val id: Int = ProductEntity.id
	}
}

```