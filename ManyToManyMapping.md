## Domain model ##

For a start, lets have a look at our domain model. It contains Products and their attributes. A product has many attributes and
an attribute can be contained within many products. In this example we will map both ways: product=>attributes and attribute=>products.

The example provide simple implementations to keep things simple:

```
class Product(val name: String, val attributes: Set[Attribute]) 
class Attribute(val name: String, val value: String, val products: Set[Product])
```

After we map those, we will be able to do operations like:

```
val product =new Product("blue jean", Set(new Attribute("colour", "blue", Set()), new Attribute("size", "medium", Set()),new Attribute("size", "large", Set())))
// lets now insert the product along with it's attributes
val inserted = mapperDao.insert(ProductEntity, product)

// lets remove the size attributes
val changed = new Product("just jean", product.attributes.filterNot(_.name == "size"));
// this will update all changed properties of product and remove the link to the size attributes (The attributes themselfs are not deleted)
val updated = mapperDao.update(ProductEntity, inserted, changed)

val selected = mapperDao.select(ProductEntity, updated.id).get
println("%d : %s".format(selected.id,selected)

mapperDao.delete(ProductEntity, updated)
```


We can also do a couple of interesting queries:

```
val p = ProductEntity
val a = AttributeEntity

import Query._

val list1=queryDao.query(
	select 
	from p 
	join (p, p.attributes, a) 
	where a.value === "46'"
)

val list2=queryDao.query(
	select 
	from p 
	join (p, p.attributes, a) 
	where a.value === "50'" 
	or a.value === "black"
)
```

## Tables ##

Typically for many-to-many relationships, we need 3 tables:
```
create table Product (
	id serial not null,
	name varchar(100) not null,
	primary key(id)
)

create table Attribute (
	id serial not null,
	name varchar(100) not null,
	value varchar(100) not null,
	primary key(id)
)

create table Product_Attribute (
	product_id int not null,
	attribute_id int not null,
	primary key(product_id,attribute_id),
	foreign key(product_id) references Product(id) on delete cascade,
	foreign key(attribute_id) references Attribute(id) on delete cascade
)
```

## Mappings ##

Lets map both entities:

```
object ProductEntity extends Entity[Int,SurrogateIntId, Product] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)
	val attributes = manytomany(AttributeEntity) to (_.attributes)

	def constructor(implicit m) = new Product(name, attributes) with Stored {
		val id:Int = ProductEntity.id
	}
}

object AttributeEntity extends Entity[Int,SurrogateIntId, Attribute] {
	val id = key("id") autogenerated (_.id)
	val name = column("name") to (_.name)
	val value = column("value") to (_.value)
	val products = manytomanyreverse(ProductEntity) to (_.products)

	def constructor(implicit m) = new Attribute(name, value, products) with Stored {
		val id:Int = AttributeEntity.id
	}
}
```

The interesting part is the manyToMany configuration for ProductEntity and AttributeEntity:
```
...
	val attributes = manytomany(AttributeEntity) to (_.attributes)
...
	val products = manytomanyreverse(ProductEntity) to (_.products)
```

The product has a many-to-many relationship with `AttributeEntity` and the link table is `Product_Attribute(product_id,attribute_id`). `product_id` is the joined column.

The attribute has a many-to-many relationship with `ProductEntity` with the link table again been `Product_Attribute` but `attribute_id` is the joined column this time.

**manytomany** creates a mapping from Product table => Product\_Attribute(product\_id,attribute\_id) link table => Attribute table.

**manytomanyreverse** creates a mapping from Attribute table => Product\_Attribute(attribute\_id,product\_id) => Product table
